{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QuestFoundry-Py","text":"<p>A powerful Python framework for creating and managing interactive narrative projects with AI integration. QuestFoundry enables you to build complex, multi-character story systems with state management, role-based processing, and sophisticated workflow orchestration.</p>"},{"location":"#key-features","title":"Key Features","text":"<p>\ud83c\udfad Multi-Role System - Dedicated roles for different aspects of storytelling (Gatekeeper, Plotwright, Scene Smith, etc.) - Role-specific provider configuration for cost optimization - Flexible role-aware provider selection</p> <p>\ud83d\udd04 Advanced Workflows - 15+ specialized loops for different narrative tasks - Composable workflow orchestration - Hot and cold artifact storage - Snapshot-based state management</p> <p>\ud83d\udcbe Intelligent Caching - Transparent response caching for API calls - Configurable per-provider or global settings - Automatic TTL and cleanup</p> <p>\u26a1 Rate Limiting &amp; Cost Control - Three-layer rate limiting (requests, tokens, cost) - Real-time cost tracking by provider - Per-provider pricing models - Budget enforcement</p> <p>\ud83d\udd10 State Management - Bidirectional state migrations - Atomic backup and restore - Project, Thematic Unit, and Snapshot tracking - Export/import for sharing and archival</p> <p>\ud83d\udcca Validation Framework - Schema validation for artifacts - Lifecycle hooks for state transitions - Custom validation rules</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install questfoundry-py\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from questfoundry.state.workspace import WorkspaceManager\nfrom questfoundry.providers.text.openai import OpenAIProvider\nfrom questfoundry.orchestrator import Orchestrator\n\n# Initialize workspace\nworkspace = WorkspaceManager(\"./my_project\")\nworkspace.init_workspace(name=\"My Story Project\")\n\n# Configure provider\nprovider_config = {\n    \"api_key\": \"your-api-key\",\n    \"model\": \"gpt-4o\"\n}\n\n# Create orchestrator\norchestrator = Orchestrator(workspace)\n\n# Run a story spark loop\nresult = orchestrator.execute_loop(\n    \"story_spark\",\n    {\"prompt\": \"A mysterious library appears...\"}\n)\n\nprint(f\"Story spark completed: {result.success}\")\n</code></pre>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#workspaces","title":"Workspaces","text":"<p>Projects are organized into workspaces with hot (active) and cold (archived) storage. Snapshots capture state at key points.</p>"},{"location":"#roles","title":"Roles","text":"<p>Specialized actors that process narrative content: - Plotwright: Plans overall story structure - Gatekeeper: Validates narrative quality and consistency - Scene Smith: Creates detailed scenes and descriptions - Illustrator: Generates images for scenes - And many more...</p>"},{"location":"#loops","title":"Loops","text":"<p>Composable workflows that orchestrate roles: - Story Spark: Initial story concept generation - Hook Generation: Create engaging story hooks - Scene Forge: Generate detailed scenes - And 12+ more specialized loops</p>"},{"location":"#state-management","title":"State Management","text":"<p>Track your project with: - ProjectInfo: Metadata and configuration - TUState: Thematic units (story segments) - SnapshotInfo: Snapshots of project state</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Step-by-step tutorial</li> <li>Installation - Installation options and setup</li> <li>API Reference - Complete API documentation</li> <li>Guides - How-to guides and best practices</li> <li>Examples - Code examples and templates</li> </ul>"},{"location":"#architecture-highlights","title":"Architecture Highlights","text":""},{"location":"#provider-system","title":"Provider System","text":"<ul> <li>Text Providers: OpenAI, Gemini, Bedrock, Ollama</li> <li>Image Providers: DALL-E, Imagen, A1111, Mock</li> <li>Audio Providers: ElevenLabs, Mock</li> <li>Pluggable architecture for custom providers</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<pre><code>providers:\n  text:\n    default: openai\n    openai:\n      api_key: ${OPENAI_API_KEY}\n      model: gpt-4o\n      cache:\n        enabled: true\n      rate_limit:\n        requests_per_minute: 60\n\nroles:\n  gatekeeper:\n    provider: openai\n    model: gpt-4o\n</code></pre>"},{"location":"#performance-features","title":"Performance Features","text":"<ul> <li>Caching: Eliminates redundant API calls</li> <li>Rate Limiting: Prevents API throttling</li> <li>Cost Tracking: Real-time budget monitoring</li> <li>Connection Pooling: Efficient resource usage</li> </ul>"},{"location":"#quality-metrics","title":"Quality Metrics","text":"<ul> <li>\u2705 824+ Tests: Comprehensive test coverage</li> <li>\u2705 Type Safety: Full mypy compliance</li> <li>\u2705 Code Quality: Clean ruff linting</li> <li>\u2705 Documentation: 100+ pages of docs</li> </ul>"},{"location":"#community","title":"Community","text":"<ul> <li>\ud83d\udce7 Issues: GitHub Issues</li> <li>\ud83d\udcac Discussions: GitHub Discussions</li> <li>\ud83d\udc26 Updates: Follow for latest news</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - See LICENSE file for details</p> <p>Ready to build your next interactive narrative? Start with the Getting Started guide!</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Epic 15: Advanced Features &amp; Polish</li> <li>Response caching layer with file-based storage</li> <li>Rate limiting with three-layer system (requests, tokens, cost)</li> <li>Per-role provider configuration</li> <li>Advanced state management with bidirectional migrations</li> <li>Cost tracking and budget enforcement</li> <li>Epic 16: Documentation &amp; Release Pipeline</li> <li>Professional MkDocs documentation site with Material theme</li> <li>Auto-generated API reference from docstrings</li> <li>Semantic versioning with commitizen</li> <li>Automated release pipeline to PyPI</li> <li>Documentation deployment to GitHub Pages</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved configuration merging for nested settings</li> <li>Cache default changed to opt-in (disabled by default)</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Configuration deep merging preserves nested dictionaries</li> <li>Side effects in cache key generation</li> <li>Code examples in documentation now tested and validated</li> </ul>"},{"location":"changelog/#010-2024-11-08","title":"[0.1.0] - 2024-11-08","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release with core QuestFoundry features</li> <li>Workspace management (hot/cold storage)</li> <li>State management with snapshots</li> <li>Provider system (text, image, audio)</li> <li>Role-based narrative processing</li> <li>15+ specialized loops for workflow automation</li> <li>Artifact lifecycle management</li> <li>Validation framework</li> <li>Response caching</li> <li>Rate limiting and cost tracking</li> <li>Per-role provider configuration</li> <li>Bidirectional state migrations</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Support for multiple AI providers (OpenAI, Gemini, Bedrock, Ollama, etc.)</li> <li>Comprehensive test coverage (824+ tests)</li> <li>Full type safety with mypy</li> <li>Clean code quality with ruff</li> <li>Extensive documentation</li> </ul> <p>This changelog will be automatically updated with each release.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to QuestFoundry-Py! This guide will help you get started.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and constructive in all interactions.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>Found a bug? Please open an issue on GitHub with:</p> <ul> <li>Clear, descriptive title</li> <li>Detailed description of the bug</li> <li>Steps to reproduce</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Python and QuestFoundry versions</li> <li>Screenshots if applicable</li> </ul>"},{"location":"contributing/#suggesting-features","title":"Suggesting Features","text":"<p>Have an idea? Open a discussion or issue with:</p> <ul> <li>Feature description</li> <li>Use case and motivation</li> <li>Proposed implementation (optional)</li> <li>Related existing features</li> </ul>"},{"location":"contributing/#code-contributions","title":"Code Contributions","text":""},{"location":"contributing/#setup-development-environment","title":"Setup Development Environment","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/pvliesdonk/questfoundry-py.git\ncd questfoundry-py\n</code></pre></p> </li> <li> <p>Create a virtual environment: <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Install in development mode: <pre><code>pip install -e \".[dev,docs]\"\n</code></pre></p> </li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Create a branch for your changes: <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes and add tests: <pre><code># Edit files\n# Add tests in tests/ directory\n</code></pre></p> </li> <li> <p>Run tests to verify: <pre><code>pytest tests/ -v\n</code></pre></p> </li> <li> <p>Run linting and type checks: <pre><code>ruff check .\nmypy src/\n</code></pre></p> </li> <li> <p>Commit with conventional commit format: <pre><code>git commit -m \"feat: add my new feature\"\ngit commit -m \"fix: resolve issue #123\"\n</code></pre></p> </li> <li> <p>Push and create a Pull Request: <pre><code>git push origin feature/your-feature-name\n</code></pre></p> </li> </ol>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Use conventional commits:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>Types: - <code>feat</code> - New feature - <code>fix</code> - Bug fix - <code>docs</code> - Documentation - <code>style</code> - Code style changes - <code>refactor</code> - Code refactoring - <code>perf</code> - Performance improvements - <code>test</code> - Test additions/changes - <code>chore</code> - Build/tool changes</p> <p>Examples: <pre><code>git commit -m \"feat: add per-role configuration support\"\ngit commit -m \"fix(providers): resolve cache key generation\"\ngit commit -m \"docs: update installation guide\"\ngit commit -m \"test: add cache tests\"\n</code></pre></p>"},{"location":"contributing/#code-standards","title":"Code Standards","text":""},{"location":"contributing/#style-guide","title":"Style Guide","text":"<ul> <li>Use PEP 8 for code style</li> <li>Use ruff for linting</li> <li>Use mypy for type checking</li> </ul>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> <pre><code>def process_artifact(artifact: Artifact, role: str) -&gt; bool:\n    \"\"\"\n    Process an artifact through a specific role.\n\n    Args:\n        artifact: The artifact to process\n        role: The role to process through\n\n    Returns:\n        True if processing was successful, False otherwise\n\n    Raises:\n        RoleError: If the role is invalid\n\n    Example:\n        &gt;&gt;&gt; artifact = Artifact(type=\"hook_card\", data={})\n        &gt;&gt;&gt; process_artifact(artifact, \"gatekeeper\")\n        True\n    \"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#type-hints","title":"Type Hints","text":"<p>Add complete type hints:</p> <pre><code>from typing import Optional\nfrom questfoundry.models import Artifact\n\ndef get_artifact(artifact_id: str) -&gt; Optional[Artifact]:\n    \"\"\"Get an artifact by ID.\"\"\"\n    pass\n\ndef process_artifacts(artifacts: list[Artifact]) -&gt; dict[str, int]:\n    \"\"\"Process multiple artifacts.\"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<pre><code>import pytest\nfrom questfoundry.models import Artifact\n\nclass TestArtifact:\n    \"\"\"Tests for Artifact model.\"\"\"\n\n    def test_artifact_creation(self) -&gt; None:\n        \"\"\"Test creating an artifact.\"\"\"\n        artifact = Artifact(\n            type=\"hook_card\",\n            data={\"title\": \"Test Hook\"},\n        )\n        assert artifact.type == \"hook_card\"\n\n    def test_artifact_with_invalid_type(self) -&gt; None:\n        \"\"\"Test artifact with invalid type.\"\"\"\n        with pytest.raises(ValueError):\n            Artifact(type=\"invalid_type\", data={})\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest tests/ -v\n\n# Run specific test file\npytest tests/test_artifacts.py -v\n\n# Run with coverage\npytest tests/ --cov=src --cov-report=html\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Add docstrings to all public classes and functions</li> <li>Update README.md for significant changes</li> <li>Add guide pages in <code>docs/guides/</code> for new features</li> <li>Update API reference pages if applicable</li> </ul>"},{"location":"contributing/#building-documentation-locally","title":"Building Documentation Locally","text":"<pre><code>pip install -e \".[docs]\"\nmkdocs serve\n</code></pre> <p>Then visit http://localhost:8000 to view the docs.</p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li> <p>Update your branch with latest main: <pre><code>git fetch origin\ngit rebase origin/main\n</code></pre></p> </li> <li> <p>Ensure all checks pass: <pre><code>pytest tests/\nruff check .\nmypy src/\n</code></pre></p> </li> <li> <p>Push and create PR with:</p> </li> <li>Clear title and description</li> <li>Reference related issues</li> <li>Mention any breaking changes</li> <li> <p>Add screenshots if UI-related</p> </li> <li> <p>Respond to reviewer feedback</p> </li> <li> <p>Once approved, maintainers will merge</p> </li> </ol>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>Releases follow Semantic Versioning:</p> <ul> <li>MAJOR: Breaking changes</li> <li>MINOR: New features</li> <li>PATCH: Bug fixes</li> </ul> <p>Commits automatically trigger version bumps: - <code>feat</code> commits \u2192 Minor version bump - <code>fix</code> commits \u2192 Patch version bump - <code>BREAKING CHANGE:</code> footer \u2192 Major version bump</p>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcd6 Check the documentation</li> <li>\ud83d\udc1b Search existing issues</li> <li>\ud83d\udcac Ask in discussions</li> <li>\ud83d\udce7 Email maintainers if needed</li> </ul>"},{"location":"contributing/#thank-you","title":"Thank You!","text":"<p>Your contributions make QuestFoundry-Py better! \ud83c\udfad</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to QuestFoundry-Py! This guide will get you up and running with your first interactive narrative project in just a few minutes.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>pip or uv package manager</li> <li>An API key from OpenAI, Gemini, or another supported provider</li> <li>Basic familiarity with Python</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>The quickest way to get started is with pip:</p> <pre><code>pip install questfoundry-py\n</code></pre> <p>For development with all extras:</p> <pre><code>pip install questfoundry-py[dev,docs]\n</code></pre>"},{"location":"getting-started/#your-first-project","title":"Your First Project","text":""},{"location":"getting-started/#step-1-create-a-project-directory","title":"Step 1: Create a Project Directory","text":"<pre><code>mkdir my_story_project\ncd my_story_project\n</code></pre>"},{"location":"getting-started/#step-2-initialize-a-workspace","title":"Step 2: Initialize a Workspace","text":"<pre><code>from questfoundry.state.workspace import WorkspaceManager\n\nworkspace = WorkspaceManager(\"./workspace\")\nworkspace.init_workspace(\n    name=\"My First Story\",\n    description=\"An interactive fantasy adventure\"\n)\n\nprint(\"Workspace initialized!\")\n</code></pre> <p>Save this as <code>init_project.py</code> and run it:</p> <pre><code>python init_project.py\n</code></pre>"},{"location":"getting-started/#step-3-configure-your-provider","title":"Step 3: Configure Your Provider","text":"<p>Create a <code>.questfoundry/config.yml</code> file:</p> <pre><code>providers:\n  text:\n    default: openai\n    openai:\n      api_key: ${OPENAI_API_KEY}\n      model: gpt-4o\n      temperature: 0.7\n</code></pre> <p>Set your API key:</p> <pre><code>export OPENAI_API_KEY=\"sk-...\"\n</code></pre>"},{"location":"getting-started/#step-4-create-a-simple-story","title":"Step 4: Create a Simple Story","text":"<pre><code>from questfoundry.state.workspace import WorkspaceManager\nfrom questfoundry.orchestrator import Orchestrator\n\n# Initialize workspace\nworkspace = WorkspaceManager(\"./workspace\")\n\n# Create orchestrator\norchestrator = Orchestrator(workspace)\n\n# Execute a story spark\nresult = orchestrator.execute_loop(\n    loop_id=\"story_spark\",\n    project_id=\"my_story_project\",\n    config={\n        \"prompt\": \"A mysterious library hidden in the mountains\",\n        \"style\": \"fantasy adventure\"\n    }\n)\n\nif result.success:\n    print(\"\u2705 Story spark completed!\")\n    print(f\"Artifacts created: {len(result.artifacts_created)}\")\n    for artifact in result.artifacts_created:\n        print(f\"  - {artifact.type}: {artifact.artifact_id}\")\nelse:\n    print(f\"\u274c Failed: {result.error}\")\n</code></pre> <p>Save as <code>create_story.py</code> and run:</p> <pre><code>python create_story.py\n</code></pre>"},{"location":"getting-started/#understanding-the-output","title":"Understanding the Output","text":"<p>The story spark loop creates several artifacts:</p> <ol> <li>Hook Card - The initial story concept</li> <li>Story Brief - Detailed story information</li> <li>TU Brief - First Thematic Unit (story segment)</li> </ol> <p>These are stored in the workspace and can be accessed programmatically.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":""},{"location":"getting-started/#explore-more-loops","title":"Explore More Loops","text":"<p>QuestFoundry includes 15+ specialized loops:</p> <pre><code># List available loops\nfrom questfoundry.orchestrator import Orchestrator\norchestrator = Orchestrator(workspace)\navailable_loops = orchestrator.get_available_loops()\n\nfor loop_name, loop_info in available_loops.items():\n    print(f\"{loop_name}: {loop_info.description}\")\n</code></pre>"},{"location":"getting-started/#configure-per-role-settings","title":"Configure Per-Role Settings","text":"<p>Use role-specific provider configuration to optimize costs:</p> <pre><code>roles:\n  gatekeeper:\n    provider: openai\n    model: gpt-4o  # Premium model for quality\n  plotwright:\n    provider: openai\n    model: gpt-3.5-turbo  # Cheaper for planning\n</code></pre>"},{"location":"getting-started/#enable-caching","title":"Enable Caching","text":"<p>Reduce API calls and costs with response caching:</p> <pre><code>providers:\n  text:\n    openai:\n      cache:\n        enabled: true\n        ttl_seconds: 3600\n</code></pre>"},{"location":"getting-started/#set-rate-limits","title":"Set Rate Limits","text":"<p>Protect your budget with rate limiting:</p> <pre><code>providers:\n  text:\n    openai:\n      rate_limit:\n        requests_per_minute: 30\n        tokens_per_hour: 90000\n        cost_per_day: 50.0\n</code></pre>"},{"location":"getting-started/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/#api-key-not-found","title":"\"API Key Not Found\"","text":"<p>Make sure your environment variable is set:</p> <pre><code>export OPENAI_API_KEY=\"sk-...\"\npython create_story.py\n</code></pre> <p>Or set it in <code>.questfoundry/config.yml</code> directly (not recommended for production).</p>"},{"location":"getting-started/#no-such-file-or-directory","title":"\"No Such File or Directory\"","text":"<p>Ensure your workspace directory exists:</p> <pre><code>import os\nos.makedirs(\"./workspace\", exist_ok=True)\n</code></pre>"},{"location":"getting-started/#rate-limit-exceeded","title":"Rate Limit Exceeded","text":"<p>Implement backoff or reduce concurrent requests:</p> <pre><code>import time\n\ntry:\n    result = orchestrator.execute_loop(\"story_spark\", params)\nexcept RateLimitError:\n    time.sleep(60)  # Wait a minute\n    result = orchestrator.execute_loop(\"story_spark\", params)\n</code></pre>"},{"location":"getting-started/#learn-more","title":"Learn More","text":"<ul> <li>Configuration Guide - All configuration options</li> <li>API Reference - Complete API documentation</li> <li>Examples - More code examples</li> <li>Guides - Create custom providers and roles</li> </ul>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcd6 Check the documentation</li> <li>\ud83d\udc1b Report issues on GitHub</li> <li>\ud83d\udcac Ask questions in Discussions</li> </ul> <p>Good luck with your narrative project! \ud83c\udfad</p>"},{"location":"installation/","title":"Installation","text":"<p>Complete installation instructions for QuestFoundry-Py across different environments and use cases.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python: 3.11 or higher</li> <li>Package Manager: pip, uv, or poetry</li> <li>Optional: Git for development installation</li> </ul>"},{"location":"installation/#standard-installation","title":"Standard Installation","text":""},{"location":"installation/#using-pip","title":"Using pip","text":"<p>The simplest way to install QuestFoundry-Py:</p> <pre><code>pip install questfoundry-py\n</code></pre>"},{"location":"installation/#using-uv","title":"Using uv","text":"<p>For faster installation with uv:</p> <pre><code>uv pip install questfoundry-py\n</code></pre>"},{"location":"installation/#using-poetry","title":"Using poetry","text":"<p>If you're using poetry for dependency management:</p> <pre><code>poetry add questfoundry-py\n</code></pre>"},{"location":"installation/#installation-with-extras","title":"Installation with Extras","text":""},{"location":"installation/#documentation-extra","title":"Documentation Extra","text":"<p>Install with documentation building tools:</p> <pre><code>pip install questfoundry-py[docs]\n</code></pre> <p>This includes: - mkdocs - mkdocs-material - mkdocstrings[python] - pymdown-extensions</p>"},{"location":"installation/#development-extra","title":"Development Extra","text":"<p>For development and testing:</p> <pre><code>pip install questfoundry-py[dev]\n</code></pre> <p>This includes: - pytest - pytest-cov - ruff - mypy - pre-commit</p>"},{"location":"installation/#all-extras","title":"All Extras","text":"<p>Install everything:</p> <pre><code>pip install questfoundry-py[dev,docs]\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":""},{"location":"installation/#from-source","title":"From Source","text":"<p>Clone and install in development mode:</p> <pre><code>git clone https://github.com/pvliesdonk/questfoundry-py.git\ncd questfoundry-py\npip install -e \".[dev,docs]\"\n</code></pre>"},{"location":"installation/#with-uv","title":"With uv","text":"<p>If using uv for faster dependency resolution:</p> <pre><code>git clone https://github.com/pvliesdonk/questfoundry-py.git\ncd questfoundry-py\nuv sync --all-extras\n</code></pre>"},{"location":"installation/#running-tests","title":"Running Tests","text":"<p>Verify the installation:</p> <pre><code>pytest tests/ -v\n</code></pre> <p>Run with coverage:</p> <pre><code>pytest tests/ --cov=src --cov-report=html\n</code></pre>"},{"location":"installation/#provider-setup","title":"Provider Setup","text":"<p>Different AI providers require specific setup steps.</p>"},{"location":"installation/#openai","title":"OpenAI","text":"<ol> <li>Get your API key from platform.openai.com</li> <li>Set environment variable:</li> </ol> <pre><code>export OPENAI_API_KEY=\"sk-...\"\n</code></pre> <ol> <li>Or configure in <code>.questfoundry/config.yml</code>:</li> </ol> <pre><code>providers:\n  text:\n    openai:\n      api_key: \"sk-...\"\n</code></pre>"},{"location":"installation/#google-gemini","title":"Google Gemini","text":"<ol> <li>Get API key from makersuite.google.com</li> <li>Install provider:</li> </ol> <pre><code>pip install google-generativeai\n</code></pre> <ol> <li>Configure:</li> </ol> <pre><code>providers:\n  text:\n    gemini:\n      api_key: ${GOOGLE_AI_API_KEY}\n</code></pre>"},{"location":"installation/#amazon-bedrock","title":"Amazon Bedrock","text":"<ol> <li>Configure AWS credentials (see AWS CLI docs)</li> <li>Install provider:</li> </ol> <pre><code>pip install boto3\n</code></pre> <ol> <li>Configure:</li> </ol> <pre><code>providers:\n  text:\n    bedrock:\n      aws_region: us-east-1\n</code></pre>"},{"location":"installation/#local-models-with-ollama","title":"Local Models with Ollama","text":"<ol> <li>Install Ollama</li> <li>Run a model:</li> </ol> <pre><code>ollama run llama2\n</code></pre> <ol> <li>Configure:</li> </ol> <pre><code>providers:\n  text:\n    ollama:\n      base_url: http://localhost:11434\n      model: llama2\n</code></pre>"},{"location":"installation/#image-providers","title":"Image Providers","text":""},{"location":"installation/#dall-e-3","title":"DALL-E 3","text":"<pre><code>pip install openai\n</code></pre> <pre><code>providers:\n  image:\n    dalle:\n      api_key: ${OPENAI_API_KEY}\n</code></pre>"},{"location":"installation/#imagen","title":"Imagen","text":"<pre><code>pip install google-cloud-aiplatform\n</code></pre> <pre><code>providers:\n  image:\n    imagen:\n      project_id: your-project\n      api_key: ${GOOGLE_CLOUD_API_KEY}\n</code></pre>"},{"location":"installation/#stable-diffusion-a1111","title":"Stable Diffusion (A1111)","text":"<pre><code>providers:\n  image:\n    a1111:\n      base_url: http://localhost:7860\n</code></pre>"},{"location":"installation/#audio-providers","title":"Audio Providers","text":""},{"location":"installation/#elevenlabs","title":"ElevenLabs","text":"<pre><code>pip install elevenlabs\n</code></pre> <pre><code>providers:\n  audio:\n    elevenlabs:\n      api_key: ${ELEVENLABS_API_KEY}\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>After installation, verify everything works:</p> <pre><code>from questfoundry import __version__\nprint(f\"QuestFoundry version: {__version__}\")\n\nfrom questfoundry.providers.text.openai import OpenAIProvider\nprint(\"OpenAI provider available\")\n\nfrom questfoundry.state.workspace import WorkspaceManager\nprint(\"Workspace manager available\")\n\nprint(\"\\n\u2705 Installation verified!\")\n</code></pre> <p>Save as <code>verify.py</code> and run:</p> <pre><code>python verify.py\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#importerror-no-module-named-questfoundry","title":"ImportError: No module named 'questfoundry'","text":"<p>The package wasn't installed. Try:</p> <pre><code>pip install --upgrade questfoundry-py\n</code></pre>"},{"location":"installation/#modulenotfounderror-no-module-named-googlegenerativeai","title":"ModuleNotFoundError: No module named 'google.generativeai'","text":"<p>You need the optional dependency for Gemini:</p> <pre><code>pip install google-generativeai\n</code></pre>"},{"location":"installation/#openai_api_key-not-found","title":"OPENAI_API_KEY not found","text":"<p>Set the environment variable:</p> <pre><code>export OPENAI_API_KEY=\"sk-...\"\n</code></pre> <p>Or configure it in your config file instead.</p>"},{"location":"installation/#version-conflicts","title":"Version conflicts","text":"<p>Try creating a fresh virtual environment:</p> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install questfoundry-py\n</code></pre>"},{"location":"installation/#still-having-issues","title":"Still having issues?","text":"<p>Check our troubleshooting guide or open an issue on GitHub.</p>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide - Create your first project</li> <li>Configuration Guide - Set up providers and roles</li> <li>API Reference - Explore the full API</li> </ul> <p>Happy creating! \ud83c\udfad</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete API reference for QuestFoundry-Py. This section documents all public modules, classes, and functions.</p>"},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#state-management","title":"State Management","text":"<p>State management system for projects, thematic units, and snapshots.</p> <ul> <li>State Module - <code>questfoundry.state</code></li> <li><code>WorkspaceManager</code> - Manage hot and cold storage</li> <li><code>StateStore</code> - State persistence</li> <li><code>SnapshotInfo</code> - Snapshot tracking</li> </ul>"},{"location":"api/#providers","title":"Providers","text":"<p>AI provider integrations for text, image, and audio generation.</p> <ul> <li>Providers Module - <code>questfoundry.providers</code></li> <li>Text providers (OpenAI, Gemini, Bedrock, Ollama)</li> <li>Image providers (DALL-E, Imagen, A1111)</li> <li>Audio providers (ElevenLabs)</li> <li>Caching and rate limiting</li> </ul>"},{"location":"api/#roles","title":"Roles","text":"<p>Role-based actors for narrative processing.</p> <ul> <li>Roles Module - <code>questfoundry.roles</code></li> <li><code>Gatekeeper</code> - Quality validation</li> <li><code>Plotwright</code> - Story planning</li> <li><code>Scene Smith</code> - Scene creation</li> <li>Custom role creation</li> </ul>"},{"location":"api/#loops","title":"Loops","text":"<p>Workflow orchestration for narrative processing.</p> <ul> <li>Loops Module - <code>questfoundry.loops</code></li> <li><code>StorySparkLoop</code> - Initial concept generation</li> <li><code>HookGenerationLoop</code> - Hook creation</li> <li><code>SceneForgeLoop</code> - Scene generation</li> <li>And 12+ more specialized loops</li> </ul>"},{"location":"api/#protocol","title":"Protocol","text":"<p>Protocol definitions and artifact handling.</p> <ul> <li>Protocol Module - <code>questfoundry.protocol</code></li> <li>Message definitions</li> <li>Request/response formats</li> <li>Protocol versioning</li> </ul>"},{"location":"api/#validation","title":"Validation","text":"<p>Schema validation and artifact validation.</p> <ul> <li>Validation Module - <code>questfoundry.validators</code></li> <li>Artifact schema validation</li> <li>Custom validators</li> <li>Validation results</li> </ul>"},{"location":"api/#module-organization","title":"Module Organization","text":"<pre><code>questfoundry/\n\u251c\u2500\u2500 state/              # State management\n\u251c\u2500\u2500 providers/          # AI providers\n\u251c\u2500\u2500 roles/              # Narrative roles\n\u251c\u2500\u2500 loops/              # Workflow loops\n\u251c\u2500\u2500 protocol/           # Protocol definitions\n\u251c\u2500\u2500 validators/         # Validation system\n\u251c\u2500\u2500 models/             # Data models\n\u2514\u2500\u2500 orchestrator.py     # Main orchestration\n</code></pre>"},{"location":"api/#common-patterns","title":"Common Patterns","text":""},{"location":"api/#creating-a-workspace","title":"Creating a Workspace","text":"<pre><code>from questfoundry.state.workspace import WorkspaceManager\n\nworkspace = WorkspaceManager(\"./my_project\")\nworkspace.init_workspace(name=\"My Project\")\n</code></pre>"},{"location":"api/#configuring-providers","title":"Configuring Providers","text":"<pre><code>from questfoundry.providers.config import ProviderConfig\n\nconfig = ProviderConfig.load(\"config.yml\")\nprovider = config.get_provider_instance(\"openai\", \"text\")\n</code></pre>"},{"location":"api/#executing-a-loop","title":"Executing a Loop","text":"<pre><code>from questfoundry.orchestrator import Orchestrator\n\norchestrator = Orchestrator(workspace)\nresult = orchestrator.execute_loop(\"story_spark\", {\"prompt\": \"...\"})\n</code></pre>"},{"location":"api/#working-with-state","title":"Working with State","text":"<pre><code>from questfoundry.state.workspace import WorkspaceManager\n\nworkspace = WorkspaceManager(\"./my_project\")\nartifact = workspace.get_artifact(\"ARTIFACT-123\")\nsnapshot = workspace.get_snapshot(\"SNAP-456\")\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>All exceptions inherit from <code>QuestFoundryError</code>:</p> <pre><code>from questfoundry.exceptions import (\n    QuestFoundryError,\n    ProviderError,\n    RoleError,\n    LoopError,\n    StateError,\n)\n\ntry:\n    result = orchestrator.execute_loop(\"story_spark\", {})\nexcept ProviderError as e:\n    print(f\"Provider error: {e}\")\nexcept RoleError as e:\n    print(f\"Role error: {e}\")\nexcept QuestFoundryError as e:\n    print(f\"QuestFoundry error: {e}\")\n</code></pre>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>All modules are fully typed with type hints. You can use them in your IDE for better autocomplete and error checking.</p>"},{"location":"api/#next-steps","title":"Next Steps","text":"<ul> <li>Providers - AI provider integration</li> <li>Roles - Narrative role system</li> <li>Loops - Workflow orchestration</li> <li>Configuration Guide - How to configure QuestFoundry</li> </ul>"},{"location":"api/export/","title":"Export API Reference","text":"<p>The <code>questfoundry.export</code> module provides tools for exporting QuestFoundry projects to various formats. It includes view generation (player-safe content filtering), Git-friendly YAML export, and book binding (rendering to HTML/Markdown).</p>"},{"location":"api/export/#overview","title":"Overview","text":"<p>The export module consists of three main components:</p> <ul> <li>ViewGenerator: Creates player-safe views from cold snapshots</li> <li>GitExporter: Exports snapshots to version-controllable YAML format</li> <li>BookBinder: Renders views to HTML and Markdown formats</li> </ul>"},{"location":"api/export/#quick-start","title":"Quick Start","text":"<pre><code>from questfoundry.export import ViewGenerator, GitExporter, BookBinder\nfrom questfoundry.state import WorkspaceManager\n\n# Initialize\nws = WorkspaceManager(\"./my-project\")\nview_gen = ViewGenerator(ws.cold_store)\ngit_exporter = GitExporter(ws.cold_store)\nbinder = BookBinder()\n\n# Generate player-safe view\nview = view_gen.generate_view(\"SNAP-2025-11-07\")\nprint(f\"View contains {len(view.artifacts)} player-safe artifacts\")\n\n# Save view\nview_gen.save_view(view)\n\n# Export to Git-friendly YAML\nexport_path = git_exporter.export_snapshot(\"SNAP-2025-11-07\", \"./export\")\nprint(f\"Exported to {export_path}\")\n\n# Render to HTML\nhtml = binder.render_html(view, title=\"Chapter 1\")\nbinder.save_html(html, \"./output/chapter1.html\")\n\n# Render to Markdown\nmarkdown = binder.render_markdown(view)\nbinder.save_markdown(markdown, \"./output/chapter1.md\")\n</code></pre>"},{"location":"api/export/#viewgenerator","title":"ViewGenerator","text":"<p>Generates player-safe views from cold snapshots by filtering artifacts based on their player_safe flag.</p>"},{"location":"api/export/#constructor","title":"Constructor","text":"<pre><code>ViewGenerator(cold_store: SQLiteStore)\n</code></pre> <p>Parameters: - <code>cold_store</code>: SQLite store for cold storage access</p> <p>Example: <pre><code>from questfoundry.export import ViewGenerator\nfrom questfoundry.state import WorkspaceManager\n\nws = WorkspaceManager(\"./project\")\ngenerator = ViewGenerator(ws.cold_store)\n</code></pre></p>"},{"location":"api/export/#methods","title":"Methods","text":""},{"location":"api/export/#generate_view","title":"<code>generate_view()</code>","text":"<pre><code>def generate_view(\n    snapshot_id: str,\n    view_id: str | None = None,\n    include_types: list[str] | None = None,\n    exclude_types: list[str] | None = None,\n) -&gt; ViewArtifact\n</code></pre> <p>Generate a view from a snapshot. Extracts all artifacts from the specified snapshot and filters to include only player-safe content.</p> <p>Parameters: - <code>snapshot_id</code>: Snapshot ID to generate view from - <code>view_id</code>: Optional view ID (auto-generated if not provided) - <code>include_types</code>: Optional list of artifact types to include (e.g., <code>[\"hook_card\", \"scene\"]</code>) - <code>exclude_types</code>: Optional list of artifact types to exclude</p> <p>Returns: ViewArtifact containing player-safe content</p> <p>Raises: - <code>ValueError</code>: If snapshot not found or no artifacts available</p> <p>Example: <pre><code># Generate full view\nview = generator.generate_view(\"SNAP-001\")\n\n# Generate view with custom ID\nview = generator.generate_view(\"SNAP-001\", view_id=\"VIEW-CHAPTER-1\")\n\n# Generate view with only specific types\nview = generator.generate_view(\n    \"SNAP-001\",\n    include_types=[\"hook_card\", \"canon_pack\"]\n)\n\n# Generate view excluding certain types\nview = generator.generate_view(\n    \"SNAP-001\",\n    exclude_types=[\"gatecheck_report\", \"tu_brief\"]\n)\n</code></pre></p>"},{"location":"api/export/#save_view","title":"<code>save_view()</code>","text":"<pre><code>def save_view(view: ViewArtifact) -&gt; None\n</code></pre> <p>Save view to cold storage. Stores the view artifact in the SQLite database for later retrieval.</p> <p>Parameters: - <code>view</code>: ViewArtifact to save</p> <p>Raises: - <code>IOError</code>: If save operation fails</p> <p>Example: <pre><code>view = generator.generate_view(\"SNAP-001\")\ngenerator.save_view(view)\nprint(f\"Saved view: {view.view_id}\")\n</code></pre></p>"},{"location":"api/export/#get_view","title":"<code>get_view()</code>","text":"<pre><code>def get_view(view_id: str) -&gt; ViewArtifact | None\n</code></pre> <p>Retrieve a previously saved view.</p> <p>Parameters: - <code>view_id</code>: View identifier</p> <p>Returns: ViewArtifact if found, None otherwise</p> <p>Example: <pre><code>view = generator.get_view(\"VIEW-CHAPTER-1\")\nif view:\n    print(f\"Found view with {len(view.artifacts)} artifacts\")\n</code></pre></p>"},{"location":"api/export/#list_views","title":"<code>list_views()</code>","text":"<pre><code>def list_views() -&gt; list[str]\n</code></pre> <p>List all saved view IDs.</p> <p>Returns: List of view IDs</p> <p>Example: <pre><code>views = generator.list_views()\nprint(f\"Available views: {views}\")\n</code></pre></p>"},{"location":"api/export/#viewartifact","title":"ViewArtifact","text":"<p>View artifact containing player-safe content. A view is a filtered collection of artifacts from a snapshot.</p>"},{"location":"api/export/#attributes","title":"Attributes","text":"<ul> <li><code>view_id</code> (str): View identifier</li> <li><code>snapshot_id</code> (str): Source snapshot ID</li> <li><code>created</code> (datetime): Creation timestamp</li> <li><code>artifacts</code> (list[Artifact]): Player-safe artifacts</li> <li><code>metadata</code> (dict[str, Any]): Additional metadata</li> </ul> <p>Example: <pre><code>view = generator.generate_view(\"SNAP-001\")\n\nprint(f\"View ID: {view.view_id}\")\nprint(f\"From snapshot: {view.snapshot_id}\")\nprint(f\"Created: {view.created}\")\nprint(f\"Artifacts: {len(view.artifacts)}\")\n\n# Access metadata\nprint(f\"Total artifacts: {view.metadata['total_artifacts']}\")\nprint(f\"Player-safe: {view.metadata['player_safe_artifacts']}\")\n\n# Iterate artifacts\nfor artifact in view.artifacts:\n    print(f\"  {artifact.type}: {artifact.artifact_id}\")\n</code></pre></p>"},{"location":"api/export/#gitexporter","title":"GitExporter","text":"<p>Exports cold snapshots to Git-friendly YAML format. Creates a human-readable directory structure suitable for version control and diffing.</p>"},{"location":"api/export/#constructor_1","title":"Constructor","text":"<pre><code>GitExporter(cold_store: SQLiteStore)\n</code></pre> <p>Parameters: - <code>cold_store</code>: SQLite store for cold storage access</p> <p>Example: <pre><code>from questfoundry.export import GitExporter\n\nexporter = GitExporter(ws.cold_store)\n</code></pre></p>"},{"location":"api/export/#directory-structure","title":"Directory Structure","text":"<p>Export creates the following structure:</p> <pre><code>export_dir/\n    manifest.yml          # Snapshot metadata and artifact index\n    hooks/\n        HOOK-001.yml\n        HOOK-002.yml\n    canon/\n        CANON-001.yml\n    scenes/\n        SCENE-001.yml\n    tus/\n        TU-2025-11-07-SR01.yml\n    gatechecks/\n        gatecheck_20251107.yml\n    ...\n</code></pre>"},{"location":"api/export/#methods_1","title":"Methods","text":""},{"location":"api/export/#export_snapshot","title":"<code>export_snapshot()</code>","text":"<pre><code>def export_snapshot(\n    snapshot_id: str,\n    export_dir: str | Path,\n    include_hot: bool = False,\n) -&gt; Path\n</code></pre> <p>Export snapshot to Git-friendly YAML format. Creates directory structure with YAML files for each artifact and a manifest file with snapshot metadata.</p> <p>Parameters: - <code>snapshot_id</code>: Snapshot ID to export - <code>export_dir</code>: Directory to export to (will be created if needed) - <code>include_hot</code>: Whether to include hot artifacts (default: False)</p> <p>Returns: Path to export directory</p> <p>Raises: - <code>ValueError</code>: If snapshot not found - <code>IOError</code>: If export fails</p> <p>Example: <pre><code># Export to directory\nexport_path = exporter.export_snapshot(\n    \"SNAP-2025-11-07\",\n    \"./exports/chapter1\"\n)\nprint(f\"Exported to: {export_path}\")\n\n# Export including hot workspace\nexport_path = exporter.export_snapshot(\n    \"SNAP-2025-11-07\",\n    \"./exports/chapter1-with-wip\",\n    include_hot=True\n)\n</code></pre></p>"},{"location":"api/export/#import_snapshot","title":"<code>import_snapshot()</code>","text":"<pre><code>def import_snapshot(\n    export_dir: str | Path,\n    target_snapshot_id: str | None = None,\n) -&gt; SnapshotInfo\n</code></pre> <p>Import snapshot from Git export directory. Reads YAML files and reconstructs artifacts in cold storage.</p> <p>Parameters: - <code>export_dir</code>: Directory containing exported snapshot - <code>target_snapshot_id</code>: Optional new snapshot ID (uses manifest ID if None)</p> <p>Returns: SnapshotInfo for imported snapshot</p> <p>Raises: - <code>ValueError</code>: If manifest not found or invalid - <code>IOError</code>: If import fails</p> <p>Example: <pre><code># Import from export directory\nsnapshot = exporter.import_snapshot(\"./exports/chapter1\")\nprint(f\"Imported snapshot: {snapshot.snapshot_id}\")\n\n# Import with new snapshot ID\nsnapshot = exporter.import_snapshot(\n    \"./exports/chapter1\",\n    target_snapshot_id=\"SNAP-IMPORTED-2025-11-07\"\n)\n</code></pre></p>"},{"location":"api/export/#manifest-format","title":"Manifest Format","text":"<p>The <code>manifest.yml</code> file contains snapshot metadata and artifact index:</p> <pre><code>version: \"1.0.0\"\nsnapshot:\n  snapshot_id: SNAP-2025-11-07\n  created: \"2025-11-07T15:30:00\"\n  tu_id: TU-2025-11-07-SR01\n  description: \"Chapter 1 complete\"\n\nartifacts:\n  hook_card:\n    - HOOK-001\n    - HOOK-002\n  canon_pack:\n    - CANON-001\n  # ... more artifact types\n\nstatistics:\n  total_artifacts: 25\n  artifact_types: 8\n  exported_at: \"2025-11-07T15:35:00\"\n</code></pre>"},{"location":"api/export/#bookbinder","title":"BookBinder","text":"<p>Renders views to various export formats (HTML, Markdown). Handles artifact ordering, formatting, and presentation.</p>"},{"location":"api/export/#constructor_2","title":"Constructor","text":"<pre><code>BookBinder(\n    html_template: str | None = None,\n    sort_artifacts: bool = True,\n)\n</code></pre> <p>Parameters: - <code>html_template</code>: Custom HTML template (uses default if None) - <code>sort_artifacts</code>: Whether to sort artifacts by type and ID (default: True)</p> <p>Example: <pre><code>from questfoundry.export import BookBinder\n\n# Use default template\nbinder = BookBinder()\n\n# Custom template\ncustom_template = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;&lt;title&gt;{title}&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;{content}&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\nbinder = BookBinder(html_template=custom_template)\n\n# Disable sorting\nbinder = BookBinder(sort_artifacts=False)\n</code></pre></p>"},{"location":"api/export/#html-rendering","title":"HTML Rendering","text":""},{"location":"api/export/#render_html","title":"<code>render_html()</code>","text":"<pre><code>def render_html(\n    view: ViewArtifact,\n    title: str | None = None\n) -&gt; str\n</code></pre> <p>Render view to HTML format.</p> <p>Parameters: - <code>view</code>: ViewArtifact to render - <code>title</code>: Page title (uses view_id if None)</p> <p>Returns: HTML string</p> <p>Example: <pre><code>view = generator.generate_view(\"SNAP-001\")\n\n# Basic rendering\nhtml = binder.render_html(view)\n\n# With custom title\nhtml = binder.render_html(view, title=\"Chapter 1: The Beginning\")\n\nprint(html)  # Complete HTML document\n</code></pre></p>"},{"location":"api/export/#save_html","title":"<code>save_html()</code>","text":"<pre><code>def save_html(\n    html: str,\n    output_path: str | Path\n) -&gt; Path\n</code></pre> <p>Save HTML to file.</p> <p>Parameters: - <code>html</code>: HTML string to save - <code>output_path</code>: Path to output file</p> <p>Returns: Path to saved file</p> <p>Example: <pre><code>html = binder.render_html(view)\noutput_path = binder.save_html(html, \"./output/chapter1.html\")\nprint(f\"Saved to: {output_path}\")\n</code></pre></p>"},{"location":"api/export/#markdown-rendering","title":"Markdown Rendering","text":""},{"location":"api/export/#render_markdown","title":"<code>render_markdown()</code>","text":"<pre><code>def render_markdown(\n    view: ViewArtifact,\n    title: str | None = None,\n    include_metadata: bool = True,\n) -&gt; str\n</code></pre> <p>Render view to Markdown format.</p> <p>Parameters: - <code>view</code>: ViewArtifact to render - <code>title</code>: Document title (uses view_id if None) - <code>include_metadata</code>: Whether to include view metadata (default: True)</p> <p>Returns: Markdown string</p> <p>Example: <pre><code>view = generator.generate_view(\"SNAP-001\")\n\n# Basic rendering\nmarkdown = binder.render_markdown(view)\n\n# With custom title, no metadata\nmarkdown = binder.render_markdown(\n    view,\n    title=\"Chapter 1\",\n    include_metadata=False\n)\n\nprint(markdown)\n</code></pre></p>"},{"location":"api/export/#save_markdown","title":"<code>save_markdown()</code>","text":"<pre><code>def save_markdown(\n    markdown: str,\n    output_path: str | Path\n) -&gt; Path\n</code></pre> <p>Save Markdown to file.</p> <p>Parameters: - <code>markdown</code>: Markdown string to save - <code>output_path</code>: Path to output file</p> <p>Returns: Path to saved file</p> <p>Example: <pre><code>markdown = binder.render_markdown(view)\noutput_path = binder.save_markdown(markdown, \"./output/chapter1.md\")\nprint(f\"Saved to: {output_path}\")\n</code></pre></p>"},{"location":"api/export/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/export/#complete-export-workflow","title":"Complete Export Workflow","text":"<pre><code>from questfoundry.export import ViewGenerator, GitExporter, BookBinder\nfrom questfoundry.state import WorkspaceManager\n\n# Initialize\nws = WorkspaceManager(\"./dragon-quest\")\nview_gen = ViewGenerator(ws.cold_store)\ngit_exporter = GitExporter(ws.cold_store)\nbinder = BookBinder()\n\nsnapshot_id = \"SNAP-2025-11-07\"\n\n# 1. Generate player-safe view\nview = view_gen.generate_view(snapshot_id)\nprint(f\"Generated view with {len(view.artifacts)} artifacts\")\n\n# 2. Save view for later use\nview_gen.save_view(view)\n\n# 3. Export to Git for version control\ngit_export_path = git_exporter.export_snapshot(\n    snapshot_id,\n    f\"./exports/{snapshot_id}\"\n)\nprint(f\"Exported to Git format: {git_export_path}\")\n\n# 4. Render to HTML for players\nhtml = binder.render_html(view, title=\"Chapter 1: Dragon's Awakening\")\nhtml_path = binder.save_html(html, \"./output/chapter1.html\")\nprint(f\"Rendered HTML: {html_path}\")\n\n# 5. Render to Markdown for review\nmarkdown = binder.render_markdown(view)\nmd_path = binder.save_markdown(markdown, \"./output/chapter1.md\")\nprint(f\"Rendered Markdown: {md_path}\")\n</code></pre>"},{"location":"api/export/#player-safe-content-filtering","title":"Player-Safe Content Filtering","text":"<pre><code># Generate view with only player-facing content\nview = view_gen.generate_view(\n    \"SNAP-001\",\n    include_types=[\n        \"hook_card\",\n        \"scene\",\n        \"canon_pack\",\n        \"codex_entry\",\n    ]\n)\n\n# Verify all artifacts are player-safe\nfor artifact in view.artifacts:\n    assert artifact.metadata.get(\"player_safe\", True)\n    print(f\"\u2713 {artifact.type}: {artifact.artifact_id} is player-safe\")\n</code></pre>"},{"location":"api/export/#git-export-for-version-control","title":"Git Export for Version Control","text":"<pre><code>import subprocess\n\n# Export snapshot\nexport_path = git_exporter.export_snapshot(\"SNAP-001\", \"./exports/v1\")\n\n# Initialize git repo (if not already)\nsubprocess.run([\"git\", \"init\"], cwd=export_path)\n\n# Add and commit\nsubprocess.run([\"git\", \"add\", \".\"], cwd=export_path)\nsubprocess.run([\n    \"git\", \"commit\", \"-m\",\n    \"Export SNAP-001: Chapter 1 complete\"\n], cwd=export_path)\n\nprint(\"Committed to git!\")\n</code></pre>"},{"location":"api/export/#import-and-re-export","title":"Import and Re-export","text":"<pre><code># Import from one export\nimported_snapshot = git_exporter.import_snapshot(\"./exports/v1\")\nprint(f\"Imported: {imported_snapshot.snapshot_id}\")\n\n# Re-export with new snapshot ID\nnew_export_path = git_exporter.export_snapshot(\n    imported_snapshot.snapshot_id,\n    \"./exports/v2\"\n)\n</code></pre>"},{"location":"api/export/#custom-html-template","title":"Custom HTML Template","text":"<pre><code># Define custom template\ncustom_template = \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;{title}&lt;/title&gt;\n    &lt;style&gt;\n        body {{\n            font-family: Arial, sans-serif;\n            background: #1a1a1a;\n            color: #f0f0f0;\n        }}\n        .artifact {{\n            border: 1px solid #333;\n            padding: 20px;\n            margin: 20px 0;\n        }}\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        {content}\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nbinder = BookBinder(html_template=custom_template)\nhtml = binder.render_html(view, title=\"Dark Fantasy Chapter\")\nbinder.save_html(html, \"./output/dark_chapter.html\")\n</code></pre>"},{"location":"api/export/#batch-export-multiple-snapshots","title":"Batch Export Multiple Snapshots","text":"<pre><code># Export all snapshots\nsnapshots = ws.cold_store.list_snapshots()\n\nfor snapshot in snapshots:\n    snapshot_id = snapshot.snapshot_id\n\n    # Generate view\n    view = view_gen.generate_view(snapshot_id)\n\n    # Export to Git\n    git_exporter.export_snapshot(\n        snapshot_id,\n        f\"./exports/{snapshot_id}\"\n    )\n\n    # Render to HTML\n    html = binder.render_html(view, title=snapshot.description)\n    binder.save_html(html, f\"./output/{snapshot_id}.html\")\n\n    print(f\"\u2713 Exported {snapshot_id}\")\n</code></pre>"},{"location":"api/export/#selective-artifact-export","title":"Selective Artifact Export","text":"<pre><code># Export only narrative content (no reports, metadata, etc.)\nnarrative_types = [\n    \"hook_card\",\n    \"scene\",\n    \"canon_pack\",\n    \"codex_entry\",\n    \"front_matter\",\n]\n\nview = view_gen.generate_view(\n    \"SNAP-001\",\n    include_types=narrative_types\n)\n\nprint(f\"Narrative view: {len(view.artifacts)} artifacts\")\n\n# Render clean player-facing output\nhtml = binder.render_html(view, title=\"Player's Guide\")\nbinder.save_html(html, \"./output/players_guide.html\")\n</code></pre>"},{"location":"api/export/#comparison-between-snapshots","title":"Comparison Between Snapshots","text":"<pre><code>from difflib import unified_diff\n\n# Export two snapshots\ngit_exporter.export_snapshot(\"SNAP-001\", \"./exports/snap1\")\ngit_exporter.export_snapshot(\"SNAP-002\", \"./exports/snap2\")\n\n# Compare manifests\nwith open(\"./exports/snap1/manifest.yml\") as f1, \\\n     open(\"./exports/snap2/manifest.yml\") as f2:\n    diff = unified_diff(\n        f1.readlines(),\n        f2.readlines(),\n        fromfile=\"SNAP-001\",\n        tofile=\"SNAP-002\"\n    )\n    print(\"\".join(diff))\n</code></pre>"},{"location":"api/export/#view-metadata-analysis","title":"View Metadata Analysis","text":"<pre><code>view = view_gen.generate_view(\"SNAP-001\")\n\n# Analyze view metadata\nprint(f\"Snapshot: {view.snapshot_id}\")\nprint(f\"View ID: {view.view_id}\")\nprint(f\"Created: {view.created}\")\nprint(f\"Total artifacts: {view.metadata['total_artifacts']}\")\nprint(f\"Player-safe: {view.metadata['player_safe_artifacts']}\")\n\n# Artifact type breakdown\ntype_counts = {}\nfor artifact in view.artifacts:\n    type_counts[artifact.type] = type_counts.get(artifact.type, 0) + 1\n\nprint(\"\\nArtifact types:\")\nfor artifact_type, count in sorted(type_counts.items()):\n    print(f\"  {artifact_type}: {count}\")\n</code></pre>"},{"location":"api/export/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always generate views before rendering:    <pre><code># Good - filtered player-safe content\nview = view_gen.generate_view(snapshot_id)\nhtml = binder.render_html(view)\n\n# Bad - might expose GM-only content\nall_artifacts = ws.list_cold_artifacts()\n# ... render directly\n</code></pre></p> </li> <li> <p>Save views for reproducibility:    <pre><code>view = view_gen.generate_view(\"SNAP-001\")\nview_gen.save_view(view)  # Can retrieve later with same filters\n</code></pre></p> </li> <li> <p>Use Git export for version control:    <pre><code># Export snapshots regularly\ngit_exporter.export_snapshot(snapshot_id, f\"./exports/{snapshot_id}\")\n# Commit to version control\n</code></pre></p> </li> <li> <p>Include only relevant types:    <pre><code># Don't export internal reports to players\nview = view_gen.generate_view(\n    snapshot_id,\n    exclude_types=[\"gatecheck_report\", \"tu_brief\", \"edit_notes\"]\n)\n</code></pre></p> </li> <li> <p>Organize exports:    <pre><code># Structured export organization\nbase_dir = Path(\"./exports\")\n(base_dir / \"snapshots\").mkdir(exist_ok=True, parents=True)\n(base_dir / \"views\").mkdir(exist_ok=True, parents=True)\n(base_dir / \"rendered\").mkdir(exist_ok=True, parents=True)\n\ngit_exporter.export_snapshot(snap_id, base_dir / \"snapshots\" / snap_id)\nbinder.save_html(html, base_dir / \"rendered\" / f\"{snap_id}.html\")\n</code></pre></p> </li> <li> <p>Custom templates for different audiences:    <pre><code>player_template = \"...\"  # Clean, simple\ngm_template = \"...\"  # Detailed, with annotations\nreview_template = \"...\"  # With change highlights\n\nplayer_binder = BookBinder(html_template=player_template)\ngm_binder = BookBinder(html_template=gm_template)\n</code></pre></p> </li> </ol>"},{"location":"api/export/#see-also","title":"See Also","text":"<ul> <li>State Management API - Snapshots and artifacts</li> <li>Validation API - Quality checks before export</li> <li>Protocol API - Message passing</li> </ul>"},{"location":"api/protocol/","title":"Protocol API Reference","text":"<p>The <code>questfoundry.protocol</code> module provides the Layer 4 protocol implementation for QuestFoundry agent communication. It implements envelope-based message passing with validation and transport abstraction.</p>"},{"location":"api/protocol/#overview","title":"Overview","text":"<p>The protocol module consists of:</p> <ul> <li>Envelope Models: Pydantic models for protocol messages</li> <li>Protocol Client: High-level API for sending/receiving messages</li> <li>Transport Layer: Abstraction for message delivery (file-based, HTTP, etc.)</li> <li>Conformance Validation: Protocol specification compliance checking</li> </ul>"},{"location":"api/protocol/#quick-start","title":"Quick Start","text":"<pre><code>from questfoundry.protocol import ProtocolClient, HotCold, SpoilerPolicy\n\n# Create a client for the Showrunner role\nclient = ProtocolClient.from_workspace(\"./my-project\", \"SR\")\n\n# Create and send a message\nenvelope = client.create_envelope(\n    receiver=\"LW\",  # Lore Weaver\n    intent=\"canon.create\",\n    payload_type=\"canon_pack\",\n    payload_data={\n        \"pack_id\": \"PACK-001\",\n        \"title\": \"World Fundamentals\",\n        \"entries\": []\n    },\n    hot_cold=HotCold.HOT,\n    player_safe=False,\n    spoilers=SpoilerPolicy.ALLOWED\n)\n\nclient.send(envelope)\n\n# Send and wait for response\nresponse = client.send_and_wait(envelope, timeout=10.0)\nif response:\n    print(f\"Received response: {response.intent}\")\n</code></pre>"},{"location":"api/protocol/#protocolclient","title":"ProtocolClient","text":"<p>The main interface for protocol communication.</p>"},{"location":"api/protocol/#constructor","title":"Constructor","text":"<pre><code>ProtocolClient(transport: Transport, sender_role: RoleName)\n</code></pre> <p>Parameters: - <code>transport</code> (Transport): Transport implementation to use - <code>sender_role</code> (RoleName): Role name for this client (e.g., \"SR\", \"GK\", \"LW\")</p>"},{"location":"api/protocol/#factory-methods","title":"Factory Methods","text":""},{"location":"api/protocol/#from_workspace","title":"<code>from_workspace()</code>","text":"<pre><code>@classmethod\ndef from_workspace(\n    cls,\n    workspace_dir: Path | str,\n    sender_role: RoleName\n) -&gt; ProtocolClient\n</code></pre> <p>Create a client using file-based transport in a workspace directory.</p> <p>Parameters: - <code>workspace_dir</code>: Path to workspace directory (creates <code>.questfoundry/hot/</code> subdirs) - <code>sender_role</code>: Role name for this client</p> <p>Returns: ProtocolClient instance</p> <p>Example: <pre><code>client = ProtocolClient.from_workspace(\"./my-adventure\", \"SR\")\n</code></pre></p>"},{"location":"api/protocol/#core-methods","title":"Core Methods","text":""},{"location":"api/protocol/#create_envelope","title":"<code>create_envelope()</code>","text":"<pre><code>def create_envelope(\n    self,\n    receiver: RoleName,\n    intent: str,\n    payload_type: str,\n    payload_data: dict[str, Any],\n    hot_cold: HotCold = HotCold.HOT,\n    player_safe: bool = True,\n    spoilers: SpoilerPolicy = SpoilerPolicy.FORBIDDEN,\n    correlation_id: str | None = None,\n    reply_to: str | None = None,\n    tu: str | None = None,\n    snapshot: str | None = None,\n    refs: list[str] | None = None,\n) -&gt; Envelope\n</code></pre> <p>Create an envelope with sensible defaults. Automatically sets protocol version, message ID, timestamp, and sender.</p> <p>Parameters: - <code>receiver</code>: Receiving role (e.g., \"GK\", \"LW\", \"SS\") - <code>intent</code>: Intent verb (e.g., \"scene.write\", \"hook.create\") - <code>payload_type</code>: Artifact type for payload (e.g., \"hook_card\", \"tu_brief\") - <code>payload_data</code>: Payload data dictionary - <code>hot_cold</code>: Workspace designation (default: HOT) - <code>player_safe</code>: Whether safe for Player Narrator (default: True) - <code>spoilers</code>: Spoiler policy (default: FORBIDDEN) - <code>correlation_id</code>: Optional correlation ID for request/response - <code>reply_to</code>: Optional message ID this replies to - <code>tu</code>: Optional TU ID (e.g., \"TU-2025-11-07-SR01\") - <code>snapshot</code>: Optional snapshot reference - <code>refs</code>: Optional list of referenced artifact IDs</p> <p>Returns: Constructed Envelope</p> <p>Example: <pre><code>envelope = client.create_envelope(\n    receiver=\"SS\",\n    intent=\"scene.write\",\n    payload_type=\"tu_brief\",\n    payload_data={\n        \"brief_id\": \"BRIEF-001\",\n        \"description\": \"Opening scene\"\n    },\n    tu=\"TU-2025-11-07-SR01\"\n)\n</code></pre></p>"},{"location":"api/protocol/#send","title":"<code>send()</code>","text":"<pre><code>def send(self, envelope: Envelope, validate: bool = True) -&gt; None\n</code></pre> <p>Send an envelope through the transport.</p> <p>Parameters: - <code>envelope</code>: The envelope to send - <code>validate</code>: Whether to validate conformance (default: True)</p> <p>Raises: - <code>ValueError</code>: If envelope fails conformance validation - <code>IOError</code>: If sending fails</p> <p>Example: <pre><code>try:\n    client.send(envelope)\nexcept ValueError as e:\n    print(f\"Validation failed: {e}\")\n</code></pre></p>"},{"location":"api/protocol/#receive","title":"<code>receive()</code>","text":"<pre><code>def receive(self, validate: bool = True) -&gt; Iterator[Envelope]\n</code></pre> <p>Receive envelopes from the transport. Returns an iterator that yields envelopes as they are received.</p> <p>Parameters: - <code>validate</code>: Whether to validate conformance (default: True)</p> <p>Yields: Envelope objects</p> <p>Raises: - <code>IOError</code>: If receiving fails</p> <p>Example: <pre><code>for envelope in client.receive():\n    print(f\"Received {envelope.intent} from {envelope.sender.role}\")\n    if envelope.intent == \"scene.complete\":\n        break\n</code></pre></p>"},{"location":"api/protocol/#send_and_wait","title":"<code>send_and_wait()</code>","text":"<pre><code>def send_and_wait(\n    self,\n    envelope: Envelope,\n    timeout: float = 10.0,\n    validate: bool = True,\n) -&gt; Envelope | None\n</code></pre> <p>Send an envelope and wait for a correlated response. Automatically adds a correlation_id if not present.</p> <p>Parameters: - <code>envelope</code>: The envelope to send - <code>timeout</code>: Timeout in seconds (default: 10.0) - <code>validate</code>: Whether to validate conformance (default: True)</p> <p>Returns: Response envelope if received, None if timeout</p> <p>Raises: - <code>ValueError</code>: If envelope fails conformance validation - <code>IOError</code>: If sending/receiving fails</p> <p>Example: <pre><code>response = client.send_and_wait(envelope, timeout=30.0)\nif response:\n    result = response.payload.data\n    print(f\"Got result: {result}\")\nelse:\n    print(\"Request timed out\")\n</code></pre></p>"},{"location":"api/protocol/#subscribe","title":"<code>subscribe()</code>","text":"<pre><code>def subscribe(\n    self,\n    intent_pattern: str,\n    callback: Callable[[Envelope], None]\n) -&gt; None\n</code></pre> <p>Subscribe to messages matching an intent pattern. The callback will be invoked for each matching message during <code>receive()</code>.</p> <p>Parameters: - <code>intent_pattern</code>: Regex pattern to match intents (e.g., <code>\"scene\\..*\"</code>, <code>\"hook\\.(create|update)\"</code>) - <code>callback</code>: Function to call with matching envelopes</p> <p>Example: <pre><code>def handle_scene_messages(envelope: Envelope):\n    print(f\"Scene message: {envelope.intent}\")\n\nclient.subscribe(r\"scene\\..*\", handle_scene_messages)\n\n# Now when you receive, callbacks are automatically invoked\nfor envelope in client.receive():\n    # Callbacks already called for matching envelopes\n    pass\n</code></pre></p>"},{"location":"api/protocol/#unsubscribe_all","title":"<code>unsubscribe_all()</code>","text":"<pre><code>def unsubscribe_all() -&gt; None\n</code></pre> <p>Remove all subscriptions.</p>"},{"location":"api/protocol/#context-manager-support","title":"Context Manager Support","text":"<p>ProtocolClient supports Python's context manager protocol:</p> <pre><code>with ProtocolClient.from_workspace(\"./my-project\", \"SR\") as client:\n    envelope = client.create_envelope(...)\n    client.send(envelope)\n# Transport is automatically closed when exiting the context\n</code></pre>"},{"location":"api/protocol/#envelope-models","title":"Envelope Models","text":""},{"location":"api/protocol/#envelope","title":"Envelope","text":"<p>The main protocol envelope wrapping all messages.</p> <p>Fields: - <code>protocol</code> (Protocol): Protocol metadata with name and version - <code>id</code> (str): Unique message ID (typically URN format) - <code>time</code> (datetime): Message creation timestamp - <code>sender</code> (Sender): Message sender information - <code>receiver</code> (Receiver): Message receiver information - <code>intent</code> (str): Intent verb (e.g., \"scene.write\", \"hook.create\") - <code>correlation_id</code> (str | None): Correlation identifier for request/response - <code>reply_to</code> (str | None): Message ID this is replying to - <code>context</code> (Context): Message context and traceability - <code>safety</code> (Safety): Safety and spoiler policies - <code>payload</code> (Payload): Message payload with type and data - <code>refs</code> (list[str]): Referenced artifact IDs</p> <p>Example: <pre><code>from questfoundry.protocol import Envelope\n\n# Typically created via EnvelopeBuilder or ProtocolClient.create_envelope()\nenvelope = Envelope(\n    protocol=Protocol(name=\"qf-protocol\", version=\"1.0.0\"),\n    id=\"urn:uuid:550e8400-e29b-41d4-a716-446655440000\",\n    time=datetime.now(),\n    sender=Sender(role=\"SR\"),\n    receiver=Receiver(role=\"LW\"),\n    intent=\"canon.create\",\n    context=Context(hot_cold=HotCold.HOT, tu=\"TU-2025-11-07-SR01\"),\n    safety=Safety(player_safe=False, spoilers=SpoilerPolicy.ALLOWED),\n    payload=Payload(type=\"canon_pack\", data={\"pack_id\": \"PACK-001\"})\n)\n</code></pre></p>"},{"location":"api/protocol/#envelopebuilder","title":"EnvelopeBuilder","text":"<p>Fluent builder for constructing envelopes. Provides a chainable interface for setting all envelope fields.</p> <p>Methods: - <code>with_protocol(version: str)</code> - Set protocol version - <code>with_id(message_id: str)</code> - Set message ID - <code>with_time(time: datetime)</code> - Set message time - <code>with_sender(role: RoleName, agent: str | None = None)</code> - Set sender - <code>with_receiver(role: RoleName)</code> - Set receiver - <code>with_intent(intent: str)</code> - Set intent - <code>with_correlation_id(correlation_id: str)</code> - Set correlation ID - <code>with_reply_to(reply_to: str)</code> - Set reply_to - <code>with_context(hot_cold, tu, snapshot, loop)</code> - Set context - <code>with_safety(player_safe, spoilers)</code> - Set safety - <code>with_payload(artifact_type, data)</code> - Set payload - <code>with_refs(refs: list[str])</code> - Set references - <code>build()</code> - Build and validate the envelope</p> <p>Example: <pre><code>from questfoundry.protocol import EnvelopeBuilder\nfrom datetime import datetime\nimport uuid\n\nenvelope = (\n    EnvelopeBuilder()\n    .with_protocol(\"1.0.0\")\n    .with_id(f\"urn:uuid:{uuid.uuid4()}\")\n    .with_time(datetime.now())\n    .with_sender(\"SR\", agent=\"human:author1\")\n    .with_receiver(\"GK\")\n    .with_intent(\"hook.validate\")\n    .with_context(HotCold.HOT, tu=\"TU-2025-11-07-SR01\")\n    .with_safety(player_safe=True, spoilers=SpoilerPolicy.FORBIDDEN)\n    .with_payload(\"hook_card\", {\"hook_id\": \"HOOK-001\"})\n    .with_refs([\"CANON-001\", \"STYLE-001\"])\n    .build()\n)\n</code></pre></p>"},{"location":"api/protocol/#protocol","title":"Protocol","text":"<p>Protocol version information.</p> <p>Fields: - <code>name</code> (str): Protocol name (always \"qf-protocol\") - <code>version</code> (str): Semantic version string (e.g., \"1.0.0\")</p>"},{"location":"api/protocol/#sender","title":"Sender","text":"<p>Message sender information.</p> <p>Fields: - <code>role</code> (RoleName): Sending role (e.g., \"SR\", \"GK\", \"LW\") - <code>agent</code> (str | None): Optional human/agent identifier (e.g., \"human:alice\")</p>"},{"location":"api/protocol/#receiver","title":"Receiver","text":"<p>Message receiver information.</p> <p>Fields: - <code>role</code> (RoleName): Receiving role (e.g., \"SR\", \"GK\", \"LW\")</p>"},{"location":"api/protocol/#context","title":"Context","text":"<p>Message context and traceability.</p> <p>Fields: - <code>hot_cold</code> (HotCold): Workspace designation (\"hot\" or \"cold\") - <code>tu</code> (str | None): Thematic Unit ID (format: \"TU-YYYY-MM-DD-ROLEXX\") - <code>snapshot</code> (str | None): Cold snapshot reference (format: \"Cold @ YYYY-MM-DD\") - <code>loop</code> (str | None): Loop/playbook context</p>"},{"location":"api/protocol/#safety","title":"Safety","text":"<p>Safety and spoiler policies.</p> <p>Fields: - <code>player_safe</code> (bool): Whether content is safe for Player Narrator (PN boundary) - <code>spoilers</code> (SpoilerPolicy): Spoiler content policy (\"forbidden\", \"allowed\", \"redacted\")</p>"},{"location":"api/protocol/#payload","title":"Payload","text":"<p>Message payload with type and data.</p> <p>Fields: - <code>type</code> (str): Payload artifact type (e.g., \"hook_card\", \"tu_brief\") - <code>data</code> (dict[str, Any]): Payload data dictionary</p>"},{"location":"api/protocol/#type-enums","title":"Type Enums","text":""},{"location":"api/protocol/#hotcold","title":"HotCold","text":"<p>Workspace designation.</p> <p>Values: - <code>HotCold.HOT</code> - \"hot\" - Work in progress - <code>HotCold.COLD</code> - \"cold\" - Curated, stable</p>"},{"location":"api/protocol/#spoilerpolicy","title":"SpoilerPolicy","text":"<p>Spoiler content policy.</p> <p>Values: - <code>SpoilerPolicy.FORBIDDEN</code> - \"forbidden\" - No spoilers allowed - <code>SpoilerPolicy.ALLOWED</code> - \"allowed\" - Spoilers permitted - <code>SpoilerPolicy.REDACTED</code> - \"redacted\" - Spoilers removed/masked</p>"},{"location":"api/protocol/#rolename","title":"RoleName","text":"<p>Role identifiers (strings). Common roles:</p> <ul> <li><code>\"SR\"</code> - Showrunner (orchestrator)</li> <li><code>\"GK\"</code> - Gatekeeper (quality validation)</li> <li><code>\"LW\"</code> - Lore Weaver (canon management)</li> <li><code>\"SS\"</code> - Scene Smith (scene writing)</li> <li><code>\"PW\"</code> - Plotwright (plot development)</li> <li><code>\"CC\"</code> - Codex Curator (codex management)</li> <li><code>\"SL\"</code> - Style Lead (style management)</li> <li><code>\"AD\"</code> - Art Director (art direction)</li> <li><code>\"IL\"</code> - Illustrator (image generation)</li> <li><code>\"AUD\"</code> - Audio Director (audio direction)</li> <li><code>\"AP\"</code> - Audio Producer (audio generation)</li> <li><code>\"PN\"</code> - Player Narrator (player interface)</li> <li><code>\"BB\"</code> - Book Binder (export/rendering)</li> <li><code>\"RS\"</code> - Researcher (research tasks)</li> <li><code>\"TR\"</code> - Translator (translation tasks)</li> </ul>"},{"location":"api/protocol/#conformance-validation","title":"Conformance Validation","text":""},{"location":"api/protocol/#validate_envelope_conformance","title":"<code>validate_envelope_conformance()</code>","text":"<pre><code>def validate_envelope_conformance(envelope: Envelope) -&gt; ConformanceResult\n</code></pre> <p>Validate envelope against protocol conformance rules.</p> <p>Parameters: - <code>envelope</code>: Envelope to validate</p> <p>Returns: ConformanceResult with conformance status and any violations</p> <p>Example: <pre><code>from questfoundry.protocol import validate_envelope_conformance\n\nresult = validate_envelope_conformance(envelope)\nif result.conformant:\n    print(\"Envelope is conformant\")\nelse:\n    for violation in result.violations:\n        print(f\"Violation: {violation.message}\")\n        print(f\"  Rule: {violation.rule}\")\n        print(f\"  Severity: {violation.severity}\")\n</code></pre></p>"},{"location":"api/protocol/#conformanceresult","title":"ConformanceResult","text":"<p>Result of conformance validation.</p> <p>Fields: - <code>conformant</code> (bool): Whether envelope is conformant - <code>violations</code> (list[ConformanceViolation]): List of violations found</p>"},{"location":"api/protocol/#conformanceviolation","title":"ConformanceViolation","text":"<p>A single conformance violation.</p> <p>Fields: - <code>rule</code> (str): Rule identifier (e.g., \"PN_BOUNDARY\") - <code>message</code> (str): Human-readable violation message - <code>severity</code> (str): \"error\" or \"warning\" - <code>field</code> (str | None): Field path where violation occurred</p>"},{"location":"api/protocol/#transport-layer","title":"Transport Layer","text":""},{"location":"api/protocol/#transport-abstract-base-class","title":"Transport (Abstract Base Class)","text":"<p>Abstract interface for message delivery.</p> <p>Methods: - <code>send(envelope: Envelope) -&gt; None</code> - Send an envelope - <code>receive() -&gt; Iterator[Envelope]</code> - Receive envelopes - <code>close() -&gt; None</code> - Close transport and release resources</p>"},{"location":"api/protocol/#filetransport","title":"FileTransport","text":"<p>File-based transport implementation using workspace directories.</p> <pre><code>from questfoundry.protocol import FileTransport\nfrom pathlib import Path\n\ntransport = FileTransport(Path(\"./my-project\"))\n\n# Send envelope\ntransport.send(envelope)\n\n# Receive envelopes\nfor envelope in transport.receive():\n    print(f\"Received: {envelope.intent}\")\n\ntransport.close()\n</code></pre> <p>Directory Structure: <pre><code>my-project/\n  .questfoundry/\n    hot/\n      envelopes/\n        inbound/\n          &lt;role&gt;/\n            &lt;timestamp&gt;-&lt;uuid&gt;.json\n        outbound/\n          &lt;role&gt;/\n            &lt;timestamp&gt;-&lt;uuid&gt;.json\n</code></pre></p>"},{"location":"api/protocol/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/protocol/#request-response-pattern","title":"Request-Response Pattern","text":"<pre><code>client = ProtocolClient.from_workspace(\"./project\", \"SR\")\n\n# Create request\nrequest = client.create_envelope(\n    receiver=\"GK\",\n    intent=\"hook.validate\",\n    payload_type=\"hook_card\",\n    payload_data={\"hook_id\": \"HOOK-001\", \"title\": \"Dragon's Lair\"}\n)\n\n# Send and wait for response\nresponse = client.send_and_wait(request, timeout=30.0)\nif response:\n    validation_result = response.payload.data\n    if validation_result.get(\"valid\"):\n        print(\"Hook is valid!\")\n    else:\n        print(f\"Validation errors: {validation_result.get('errors')}\")\n</code></pre>"},{"location":"api/protocol/#event-broadcasting-pattern","title":"Event Broadcasting Pattern","text":"<pre><code># Broadcaster\nclient = ProtocolClient.from_workspace(\"./project\", \"SR\")\n\nevent = client.create_envelope(\n    receiver=\"*\",  # Broadcast to all roles\n    intent=\"loop.started\",\n    payload_type=\"loop_event\",\n    payload_data={\"loop\": \"hook_harvest\", \"tu\": \"TU-2025-11-07-SR01\"}\n)\n\nclient.send(event)\n</code></pre>"},{"location":"api/protocol/#subscription-pattern","title":"Subscription Pattern","text":"<pre><code>client = ProtocolClient.from_workspace(\"./project\", \"GK\")\n\n# Set up handlers for different intent patterns\ndef handle_hook_validation(envelope: Envelope):\n    hook_data = envelope.payload.data\n    # Validate hook...\n    # Send response...\n\ndef handle_scene_validation(envelope: Envelope):\n    scene_data = envelope.payload.data\n    # Validate scene...\n\nclient.subscribe(r\"hook\\.(validate|check)\", handle_hook_validation)\nclient.subscribe(r\"scene\\.validate\", handle_scene_validation)\n\n# Process messages\nfor envelope in client.receive():\n    # Subscribed handlers are automatically invoked\n    pass\n</code></pre>"},{"location":"api/protocol/#async-message-processing","title":"Async Message Processing","text":"<pre><code>import threading\nimport queue\n\nmessage_queue = queue.Queue()\n\ndef receive_loop(client):\n    \"\"\"Background thread for receiving messages\"\"\"\n    for envelope in client.receive():\n        message_queue.put(envelope)\n\nclient = ProtocolClient.from_workspace(\"./project\", \"SR\")\n\n# Start receiving in background\nreceiver_thread = threading.Thread(target=receive_loop, args=(client,))\nreceiver_thread.daemon = True\nreceiver_thread.start()\n\n# Process messages from queue\nwhile True:\n    try:\n        envelope = message_queue.get(timeout=1.0)\n        print(f\"Processing: {envelope.intent}\")\n    except queue.Empty:\n        continue\n</code></pre>"},{"location":"api/protocol/#error-handling","title":"Error Handling","text":"<pre><code>from questfoundry.protocol import ProtocolClient\nfrom pydantic import ValidationError\n\nclient = ProtocolClient.from_workspace(\"./project\", \"SR\")\n\ntry:\n    envelope = client.create_envelope(\n        receiver=\"INVALID\",  # Invalid role\n        intent=\"test\",\n        payload_type=\"test\",\n        payload_data={}\n    )\nexcept ValidationError as e:\n    print(f\"Validation error: {e}\")\n\ntry:\n    client.send(envelope)\nexcept ValueError as e:\n    print(f\"Conformance error: {e}\")\nexcept IOError as e:\n    print(f\"Transport error: {e}\")\n</code></pre>"},{"location":"api/protocol/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always use context managers when possible to ensure resources are cleaned up:    <pre><code>with ProtocolClient.from_workspace(\"./project\", \"SR\") as client:\n    # Use client...\n</code></pre></p> </li> <li> <p>Enable validation by default - Only disable for performance-critical code paths:    <pre><code>client.send(envelope, validate=True)  # Default\n</code></pre></p> </li> <li> <p>Use correlation IDs for request-response patterns:    <pre><code>response = client.send_and_wait(request)\n</code></pre></p> </li> <li> <p>Set appropriate timeouts for send_and_wait:    <pre><code>response = client.send_and_wait(request, timeout=30.0)\nif not response:\n    print(\"Timeout - no response received\")\n</code></pre></p> </li> <li> <p>Use subscriptions for event-driven architectures:    <pre><code>client.subscribe(r\"hook\\..*\", handler)\n</code></pre></p> </li> <li> <p>Set player_safe carefully to enforce PN boundaries:    <pre><code>envelope = client.create_envelope(\n    ...,\n    player_safe=False,  # Contains GM-only information\n    spoilers=SpoilerPolicy.ALLOWED\n)\n</code></pre></p> </li> </ol>"},{"location":"api/protocol/#see-also","title":"See Also","text":"<ul> <li>State Management API - SQLite and file-based state management</li> <li>Validation API - Schema and conformance validation</li> <li>Export API - View generation and export</li> </ul>"},{"location":"api/providers/","title":"Provider API Reference","text":"<p>The <code>questfoundry.providers</code> module provides a pluggable architecture for integrating with external AI services (LLMs, image generation, audio generation, etc.). It implements a registry pattern with configuration management and automatic provider discovery.</p>"},{"location":"api/providers/#overview","title":"Overview","text":"<p>The provider system consists of:</p> <ul> <li>Provider Base Classes: Abstract interfaces for different provider types</li> <li>Provider Registry: Central registry for discovering and instantiating providers</li> <li>Provider Config: Configuration management with environment variable support</li> <li>Built-in Providers: Text (OpenAI, Ollama) and Image (DALL-E, Automatic1111)</li> </ul>"},{"location":"api/providers/#quick-start","title":"Quick Start","text":"<pre><code>from questfoundry.providers import ProviderRegistry, ProviderConfig\n\n# Load configuration (from .questfoundry/config.yml)\nconfig = ProviderConfig()\nregistry = ProviderRegistry(config)\n\n# Get text provider (default or by name)\ntext_provider = registry.get_text_provider()  # Uses default\n# text_provider = registry.get_text_provider(\"openai\")  # Specific provider\n\n# Generate text\nresponse = text_provider.generate_text(\n    prompt=\"Write a fantasy hook about a dragon\",\n    max_tokens=200,\n    temperature=0.7\n)\nprint(response)\n\n# Get image provider\nimage_provider = registry.get_image_provider(\"dalle\")\n\n# Generate image\nimage_data = image_provider.generate_image(\n    prompt=\"A majestic dragon perched on ancient ruins\",\n    width=1024,\n    height=1024\n)\n\n# Save image\nwith open(\"dragon.png\", \"wb\") as f:\n    f.write(image_data)\n</code></pre>"},{"location":"api/providers/#providerconfig","title":"ProviderConfig","text":"<p>Manages provider configuration with environment variable substitution.</p>"},{"location":"api/providers/#constructor","title":"Constructor","text":"<pre><code>ProviderConfig(config_path: Path | str | None = None)\n</code></pre> <p>Parameters: - <code>config_path</code>: Path to config file. If None, looks for <code>.questfoundry/config.yml</code> in current directory.</p> <p>Configuration File Format (YAML):</p> <pre><code>providers:\n  text:\n    default: openai\n    openai:\n      api_key: ${OPENAI_API_KEY}\n      model: gpt-4o\n      organization: org-xxxxx  # Optional\n    ollama:\n      base_url: http://localhost:11434\n      model: llama3\n\n  image:\n    default: dalle\n    dalle:\n      api_key: ${OPENAI_API_KEY}\n      model: dall-e-3\n    a1111:\n      base_url: http://localhost:7860\n      model: sd-xl\n</code></pre> <p>Environment Variable Substitution:</p> <p>The config supports <code>${ENV_VAR}</code> syntax for referencing environment variables:</p> <pre><code>api_key: ${OPENAI_API_KEY}\n</code></pre> <p>This will be replaced with the value of <code>OPENAI_API_KEY</code> environment variable when the config is loaded.</p> <p>Example: <pre><code>from questfoundry.providers import ProviderConfig\n\n# Load from default location\nconfig = ProviderConfig()\n\n# Load from custom path\nconfig = ProviderConfig(\"/path/to/config.yml\")\n\n# Load will raise ValueError if referenced environment variables are not set\n</code></pre></p>"},{"location":"api/providers/#methods","title":"Methods","text":""},{"location":"api/providers/#load","title":"<code>load()</code>","text":"<pre><code>def load() -&gt; None\n</code></pre> <p>Load configuration from file.</p> <p>Raises: - <code>FileNotFoundError</code>: If config file doesn't exist - <code>ValueError</code>: If config file is invalid YAML or if a referenced environment variable is not set</p> <p>Example: <pre><code>config = ProviderConfig(\"./config.yml\")\ntry:\n    config.load()\nexcept FileNotFoundError:\n    print(\"Config file not found\")\nexcept ValueError as e:\n    print(f\"Invalid config: {e}\")\n</code></pre></p>"},{"location":"api/providers/#save","title":"<code>save()</code>","text":"<pre><code>def save() -&gt; None\n</code></pre> <p>Save configuration to file. Creates parent directories if they don't exist.</p> <p>Example: <pre><code>config = ProviderConfig()\nconfig.set_default_provider(\"text\", \"ollama\")\nconfig.save()\n</code></pre></p>"},{"location":"api/providers/#get_provider_config","title":"<code>get_provider_config()</code>","text":"<pre><code>def get_provider_config(\n    provider_type: str,\n    provider_name: str\n) -&gt; dict[str, Any]\n</code></pre> <p>Get configuration for a specific provider.</p> <p>Parameters: - <code>provider_type</code>: Type of provider (\"text\" or \"image\") - <code>provider_name</code>: Name of provider (e.g., \"openai\", \"ollama\")</p> <p>Returns: Provider configuration dictionary</p> <p>Raises: - <code>KeyError</code>: If provider not found in configuration</p> <p>Example: <pre><code>openai_config = config.get_provider_config(\"text\", \"openai\")\nprint(f\"Model: {openai_config['model']}\")\nprint(f\"API Key: {openai_config['api_key']}\")\n</code></pre></p>"},{"location":"api/providers/#get_default_provider","title":"<code>get_default_provider()</code>","text":"<pre><code>def get_default_provider(provider_type: str) -&gt; str | None\n</code></pre> <p>Get default provider name for a type.</p> <p>Parameters: - <code>provider_type</code>: Type of provider (\"text\" or \"image\")</p> <p>Returns: Default provider name, or None if not configured</p> <p>Example: <pre><code>default_text = config.get_default_provider(\"text\")\nprint(f\"Default text provider: {default_text}\")\n</code></pre></p>"},{"location":"api/providers/#set_default_provider","title":"<code>set_default_provider()</code>","text":"<pre><code>def set_default_provider(\n    provider_type: str,\n    provider_name: str\n) -&gt; None\n</code></pre> <p>Set default provider for a type.</p> <p>Parameters: - <code>provider_type</code>: Type of provider (\"text\" or \"image\") - <code>provider_name</code>: Name of provider</p> <p>Example: <pre><code>config.set_default_provider(\"text\", \"ollama\")\nconfig.save()  # Persist to file\n</code></pre></p>"},{"location":"api/providers/#list_providers","title":"<code>list_providers()</code>","text":"<pre><code>def list_providers(provider_type: str) -&gt; list[str]\n</code></pre> <p>List available providers of a given type in configuration.</p> <p>Parameters: - <code>provider_type</code>: Type of provider (\"text\" or \"image\")</p> <p>Returns: List of provider names</p> <p>Example: <pre><code>text_providers = config.list_providers(\"text\")\nprint(f\"Available text providers: {text_providers}\")\n# Output: ['openai', 'ollama']\n</code></pre></p>"},{"location":"api/providers/#providerregistry","title":"ProviderRegistry","text":"<p>Registry for managing text and image providers. Handles provider instantiation, configuration, and caching.</p>"},{"location":"api/providers/#constructor_1","title":"Constructor","text":"<pre><code>ProviderRegistry(config: ProviderConfig)\n</code></pre> <p>Parameters: - <code>config</code>: Provider configuration</p> <p>Example: <pre><code>from questfoundry.providers import ProviderRegistry, ProviderConfig\n\nconfig = ProviderConfig()\nregistry = ProviderRegistry(config)\n</code></pre></p>"},{"location":"api/providers/#provider-access-methods","title":"Provider Access Methods","text":""},{"location":"api/providers/#get_text_provider","title":"<code>get_text_provider()</code>","text":"<pre><code>def get_text_provider(name: str | None = None) -&gt; TextProvider\n</code></pre> <p>Get or create a text provider instance. Instances are cached for reuse.</p> <p>Parameters: - <code>name</code>: Provider name. If None, uses default from config.</p> <p>Returns: Text provider instance</p> <p>Raises: - <code>ValueError</code>: If provider not found or not registered, or if no default configured</p> <p>Example: <pre><code># Get default text provider\nprovider = registry.get_text_provider()\n\n# Get specific provider\nopenai = registry.get_text_provider(\"openai\")\nollama = registry.get_text_provider(\"ollama\")\n\n# Cached - returns same instance\nprovider2 = registry.get_text_provider()\nassert provider is provider2\n</code></pre></p>"},{"location":"api/providers/#get_image_provider","title":"<code>get_image_provider()</code>","text":"<pre><code>def get_image_provider(name: str | None = None) -&gt; ImageProvider\n</code></pre> <p>Get or create an image provider instance. Instances are cached for reuse.</p> <p>Parameters: - <code>name</code>: Provider name. If None, uses default from config.</p> <p>Returns: Image provider instance</p> <p>Raises: - <code>ValueError</code>: If provider not found or not registered, or if no default configured</p> <p>Example: <pre><code># Get default image provider\nprovider = registry.get_image_provider()\n\n# Get specific provider\ndalle = registry.get_image_provider(\"dalle\")\nsd = registry.get_image_provider(\"a1111\")\n</code></pre></p>"},{"location":"api/providers/#provider-registration-methods","title":"Provider Registration Methods","text":""},{"location":"api/providers/#register_text_provider","title":"<code>register_text_provider()</code>","text":"<pre><code>def register_text_provider(\n    name: str,\n    provider_class: type[TextProvider]\n) -&gt; None\n</code></pre> <p>Register a custom text provider class.</p> <p>Parameters: - <code>name</code>: Provider name (e.g., \"custom\", \"anthropic\") - <code>provider_class</code>: Provider class to register (must extend TextProvider)</p> <p>Example: <pre><code>from questfoundry.providers import TextProvider\n\nclass CustomTextProvider(TextProvider):\n    def validate_config(self):\n        # Implementation...\n        pass\n\n    def generate_text(self, prompt, **kwargs):\n        # Implementation...\n        return \"generated text\"\n\n    def generate_text_streaming(self, prompt, **kwargs):\n        # Implementation...\n        yield \"chunk1\"\n\nregistry.register_text_provider(\"custom\", CustomTextProvider)\n\n# Now can use it\nprovider = registry.get_text_provider(\"custom\")\n</code></pre></p>"},{"location":"api/providers/#register_image_provider","title":"<code>register_image_provider()</code>","text":"<pre><code>def register_image_provider(\n    name: str,\n    provider_class: type[ImageProvider]\n) -&gt; None\n</code></pre> <p>Register a custom image provider class.</p> <p>Parameters: - <code>name</code>: Provider name (e.g., \"midjourney\", \"imagen\") - <code>provider_class</code>: Provider class to register (must extend ImageProvider)</p> <p>Example: <pre><code>from questfoundry.providers import ImageProvider\n\nclass CustomImageProvider(ImageProvider):\n    def validate_config(self):\n        # Implementation...\n        pass\n\n    def generate_image(self, prompt, **kwargs):\n        # Implementation...\n        return b\"...image bytes...\"\n\nregistry.register_image_provider(\"custom\", CustomImageProvider)\n</code></pre></p>"},{"location":"api/providers/#utility-methods","title":"Utility Methods","text":""},{"location":"api/providers/#list_text_providers","title":"<code>list_text_providers()</code>","text":"<pre><code>def list_text_providers() -&gt; list[str]\n</code></pre> <p>List registered text providers.</p> <p>Returns: List of text provider names</p> <p>Example: <pre><code>providers = registry.list_text_providers()\nprint(f\"Available: {providers}\")\n# Output: ['openai', 'ollama', 'custom']\n</code></pre></p>"},{"location":"api/providers/#list_image_providers","title":"<code>list_image_providers()</code>","text":"<pre><code>def list_image_providers() -&gt; list[str]\n</code></pre> <p>List registered image providers.</p> <p>Returns: List of image provider names</p> <p>Example: <pre><code>providers = registry.list_image_providers()\nprint(f\"Available: {providers}\")\n# Output: ['dalle', 'a1111']\n</code></pre></p>"},{"location":"api/providers/#close_all","title":"<code>close_all()</code>","text":"<pre><code>def close_all() -&gt; None\n</code></pre> <p>Close all provider instances and release resources. Clears the instance cache.</p> <p>Example: <pre><code># Use providers...\n# ...\n\n# Clean up all resources\nregistry.close_all()\n</code></pre></p>"},{"location":"api/providers/#base-classes","title":"Base Classes","text":""},{"location":"api/providers/#provider","title":"Provider","text":"<p>Abstract base class for all providers.</p> <p>Methods:</p>"},{"location":"api/providers/#__init__config-dictstr-any","title":"<code>__init__(config: dict[str, Any])</code>","text":"<p>Initialize provider with configuration.</p>"},{"location":"api/providers/#validate_config-none-abstract","title":"<code>validate_config() -&gt; None</code> (abstract)","text":"<p>Validate provider configuration. Must be implemented by subclasses.</p> <p>Raises: - <code>ValueError</code>: If configuration is invalid</p>"},{"location":"api/providers/#close-none","title":"<code>close() -&gt; None</code>","text":"<p>Close provider and release resources. Default implementation does nothing, but providers can override to cleanup connections.</p> <p>Context Manager Support:</p> <p>All providers support context manager protocol:</p> <pre><code>with registry.get_text_provider(\"openai\") as provider:\n    result = provider.generate_text(\"Hello\")\n# Provider automatically closed\n</code></pre>"},{"location":"api/providers/#textprovider","title":"TextProvider","text":"<p>Abstract base class for text generation providers. Extends Provider.</p> <p>Abstract Methods:</p>"},{"location":"api/providers/#generate_text","title":"<code>generate_text()</code>","text":"<pre><code>def generate_text(\n    prompt: str,\n    model: str | None = None,\n    max_tokens: int | None = None,\n    temperature: float | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Generate text from a prompt.</p> <p>Parameters: - <code>prompt</code>: The input prompt - <code>model</code>: Model to use (uses default if not specified) - <code>max_tokens</code>: Maximum tokens to generate - <code>temperature</code>: Sampling temperature (0.0 to 2.0) - <code>**kwargs</code>: Additional provider-specific parameters</p> <p>Returns: Generated text</p> <p>Raises: - <code>ValueError</code>: If parameters are invalid - <code>RuntimeError</code>: If generation fails</p>"},{"location":"api/providers/#generate_text_streaming","title":"<code>generate_text_streaming()</code>","text":"<pre><code>def generate_text_streaming(\n    prompt: str,\n    model: str | None = None,\n    max_tokens: int | None = None,\n    temperature: float | None = None,\n    **kwargs: Any,\n) -&gt; Iterator[str]\n</code></pre> <p>Generate text from a prompt with streaming.</p> <p>Parameters: Same as <code>generate_text()</code></p> <p>Yields: Text chunks as they are generated</p> <p>Raises: - <code>ValueError</code>: If parameters are invalid - <code>RuntimeError</code>: If generation fails</p>"},{"location":"api/providers/#imageprovider","title":"ImageProvider","text":"<p>Abstract base class for image generation providers. Extends Provider.</p> <p>Abstract Method:</p>"},{"location":"api/providers/#generate_image","title":"<code>generate_image()</code>","text":"<pre><code>def generate_image(\n    prompt: str,\n    model: str | None = None,\n    width: int | None = None,\n    height: int | None = None,\n    **kwargs: Any,\n) -&gt; bytes\n</code></pre> <p>Generate an image from a text prompt.</p> <p>Parameters: - <code>prompt</code>: The text prompt describing the image - <code>model</code>: Model to use (uses default if not specified) - <code>width</code>: Image width in pixels - <code>height</code>: Image height in pixels - <code>**kwargs</code>: Additional provider-specific parameters</p> <p>Returns: Image data as bytes (typically PNG format)</p> <p>Raises: - <code>ValueError</code>: If parameters are invalid - <code>RuntimeError</code>: If generation fails</p>"},{"location":"api/providers/#built-in-providers","title":"Built-in Providers","text":""},{"location":"api/providers/#text-providers","title":"Text Providers","text":""},{"location":"api/providers/#openaiprovider","title":"OpenAIProvider","text":"<p>OpenAI text generation provider using GPT models.</p> <p>Configuration: <pre><code>providers:\n  text:\n    openai:\n      api_key: ${OPENAI_API_KEY}  # Required\n      model: gpt-4o              # Optional, default: gpt-4o\n      organization: org-xxxxx     # Optional\n      base_url: https://...       # Optional (for proxies)\n</code></pre></p> <p>Installation: <pre><code>pip install questfoundry-py[openai]\n</code></pre></p> <p>Example: <pre><code>provider = registry.get_text_provider(\"openai\")\n\n# Basic generation\ntext = provider.generate_text(\n    prompt=\"Write a fantasy scene\",\n    max_tokens=500,\n    temperature=0.7\n)\n\n# With OpenAI-specific parameters\ntext = provider.generate_text(\n    prompt=\"Write a fantasy scene\",\n    max_tokens=500,\n    temperature=0.7,\n    top_p=0.9,\n    frequency_penalty=0.5,\n    presence_penalty=0.5\n)\n\n# Streaming\nfor chunk in provider.generate_text_streaming(\n    prompt=\"Write a long story\",\n    temperature=0.8\n):\n    print(chunk, end=\"\", flush=True)\n</code></pre></p> <p>Supported Models: - gpt-4o (default) - gpt-4-turbo - gpt-4 - gpt-3.5-turbo - All OpenAI chat models</p>"},{"location":"api/providers/#ollamaprovider","title":"OllamaProvider","text":"<p>Local Ollama text generation provider.</p> <p>Configuration: <pre><code>providers:\n  text:\n    ollama:\n      base_url: http://localhost:11434  # Required\n      model: llama3                     # Optional, default: llama3\n</code></pre></p> <p>Installation: <pre><code>pip install questfoundry-py[ollama]\n# Also requires Ollama running locally\n</code></pre></p> <p>Example: <pre><code>provider = registry.get_text_provider(\"ollama\")\n\ntext = provider.generate_text(\n    prompt=\"Write a fantasy hook\",\n    max_tokens=200,\n    temperature=0.9\n)\n\n# Streaming\nfor chunk in provider.generate_text_streaming(prompt=\"Tell a story\"):\n    print(chunk, end=\"\", flush=True)\n</code></pre></p> <p>Supported Models: - llama3 (default) - llama2 - mistral - Any model available in your Ollama installation</p>"},{"location":"api/providers/#image-providers","title":"Image Providers","text":""},{"location":"api/providers/#dalleprovider","title":"DalleProvider","text":"<p>OpenAI DALL-E image generation provider.</p> <p>Configuration: <pre><code>providers:\n  image:\n    dalle:\n      api_key: ${OPENAI_API_KEY}  # Required\n      model: dall-e-3              # Optional, default: dall-e-3\n</code></pre></p> <p>Installation: <pre><code>pip install questfoundry-py[openai]\n</code></pre></p> <p>Example: <pre><code>provider = registry.get_image_provider(\"dalle\")\n\nimage_data = provider.generate_image(\n    prompt=\"A majestic dragon on a mountain peak\",\n    width=1024,\n    height=1024,\n    # DALL-E specific parameters\n    quality=\"hd\",\n    style=\"vivid\"\n)\n\nwith open(\"dragon.png\", \"wb\") as f:\n    f.write(image_data)\n</code></pre></p> <p>Supported Models: - dall-e-3 (default) - 1024x1024, 1024x1792, 1792x1024 - dall-e-2 - 256x256, 512x512, 1024x1024</p>"},{"location":"api/providers/#automatic1111provider","title":"Automatic1111Provider","text":"<p>Stable Diffusion via Automatic1111 Web UI.</p> <p>Configuration: <pre><code>providers:\n  image:\n    a1111:\n      base_url: http://localhost:7860  # Required\n      model: sd-xl                     # Optional, default: sd-xl\n</code></pre></p> <p>Installation: <pre><code>pip install questfoundry-py[image]\n# Also requires Automatic1111 Web UI running locally\n</code></pre></p> <p>Example: <pre><code>provider = registry.get_image_provider(\"a1111\")\n\nimage_data = provider.generate_image(\n    prompt=\"fantasy dragon, highly detailed, 4k\",\n    width=512,\n    height=512,\n    # A1111 specific parameters\n    negative_prompt=\"blurry, low quality\",\n    steps=30,\n    cfg_scale=7.5,\n    sampler_name=\"Euler a\"\n)\n\nwith open(\"dragon.png\", \"wb\") as f:\n    f.write(image_data)\n</code></pre></p> <p>Supported Parameters: - <code>negative_prompt</code>: What to avoid in generation - <code>steps</code>: Number of inference steps (default: 20) - <code>cfg_scale</code>: Classifier-free guidance scale (default: 7.0) - <code>sampler_name</code>: Sampler algorithm (e.g., \"Euler a\", \"DPM++ 2M\") - <code>seed</code>: Random seed for reproducibility</p>"},{"location":"api/providers/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/providers/#basic-text-generation","title":"Basic Text Generation","text":"<pre><code>from questfoundry.providers import ProviderRegistry, ProviderConfig\n\nconfig = ProviderConfig()\nregistry = ProviderRegistry(config)\n\n# Get provider\nprovider = registry.get_text_provider()\n\n# Generate text\nscene = provider.generate_text(\n    prompt=\"\"\"\nWrite a fantasy scene where the protagonist discovers\nan ancient artifact in a forgotten temple.\n\"\"\",\n    max_tokens=500,\n    temperature=0.8\n)\n\nprint(scene)\n</code></pre>"},{"location":"api/providers/#streaming-text-generation","title":"Streaming Text Generation","text":"<pre><code>provider = registry.get_text_provider(\"openai\")\n\nprint(\"Generating story...\")\nfor chunk in provider.generate_text_streaming(\n    prompt=\"Write a long adventure story\",\n    max_tokens=2000,\n    temperature=0.9\n):\n    print(chunk, end=\"\", flush=True)\nprint(\"\\nDone!\")\n</code></pre>"},{"location":"api/providers/#image-generation","title":"Image Generation","text":"<pre><code>provider = registry.get_image_provider(\"dalle\")\n\n# Generate image\nimage_data = provider.generate_image(\n    prompt=\"A mystical forest with glowing mushrooms\",\n    width=1024,\n    height=1024\n)\n\n# Save to file\nfrom pathlib import Path\noutput = Path(\"generated_images\")\noutput.mkdir(exist_ok=True)\n(output / \"forest.png\").write_bytes(image_data)\n</code></pre>"},{"location":"api/providers/#multi-provider-setup","title":"Multi-Provider Setup","text":"<pre><code># Use different providers for different tasks\nopenai = registry.get_text_provider(\"openai\")\nollama = registry.get_text_provider(\"ollama\")\ndalle = registry.get_image_provider(\"dalle\")\n\n# Use OpenAI for creative writing\nstory = openai.generate_text(\n    prompt=\"Write a dramatic scene\",\n    temperature=0.9\n)\n\n# Use Ollama for structured output (faster, cheaper)\nsummary = ollama.generate_text(\n    prompt=f\"Summarize this scene in 3 bullet points:\\n\\n{story}\",\n    temperature=0.3\n)\n\n# Generate illustration\nimage = dalle.generate_image(\n    prompt=summary,\n    width=1024,\n    height=1024\n)\n</code></pre>"},{"location":"api/providers/#provider-comparison","title":"Provider Comparison","text":"<pre><code>providers = [\"openai\", \"ollama\"]\nprompt = \"Write a short fantasy hook about a dragon\"\n\nresults = {}\nfor provider_name in providers:\n    provider = registry.get_text_provider(provider_name)\n    result = provider.generate_text(prompt, max_tokens=100)\n    results[provider_name] = result\n\nfor name, text in results.items():\n    print(f\"\\n{name}:\\n{text}\\n\")\n</code></pre>"},{"location":"api/providers/#error-handling","title":"Error Handling","text":"<pre><code>from questfoundry.providers import ProviderRegistry, ProviderConfig\n\ntry:\n    config = ProviderConfig()\n    registry = ProviderRegistry(config)\n    provider = registry.get_text_provider(\"openai\")\n\n    text = provider.generate_text(\"Write a scene\")\n    print(text)\n\nexcept ValueError as e:\n    # Configuration or parameter errors\n    print(f\"Configuration error: {e}\")\n\nexcept RuntimeError as e:\n    # API call failures\n    print(f\"Generation failed: {e}\")\n\nexcept ImportError as e:\n    # Missing dependencies\n    print(f\"Install required package: {e}\")\n</code></pre>"},{"location":"api/providers/#context-manager-pattern","title":"Context Manager Pattern","text":"<pre><code>config = ProviderConfig()\nregistry = ProviderRegistry(config)\n\n# Automatic cleanup\nwith registry.get_text_provider(\"openai\") as provider:\n    result = provider.generate_text(\"Hello world\")\n# Provider closed automatically\n\n# Or manually\nprovider = registry.get_text_provider(\"openai\")\ntry:\n    result = provider.generate_text(\"Hello world\")\nfinally:\n    provider.close()\n</code></pre>"},{"location":"api/providers/#custom-provider-implementation","title":"Custom Provider Implementation","text":"<pre><code>from questfoundry.providers import TextProvider\nfrom typing import Any, Iterator\n\nclass MyCustomProvider(TextProvider):\n    \"\"\"Custom text provider implementation.\"\"\"\n\n    def validate_config(self) -&gt; None:\n        \"\"\"Validate configuration.\"\"\"\n        if \"api_key\" not in self.config:\n            raise ValueError(\"api_key required\")\n\n    def generate_text(\n        self,\n        prompt: str,\n        model: str | None = None,\n        max_tokens: int | None = None,\n        temperature: float | None = None,\n        **kwargs: Any,\n    ) -&gt; str:\n        \"\"\"Generate text.\"\"\"\n        # Your implementation here\n        api_key = self.config[\"api_key\"]\n        # ... call your API ...\n        return \"generated text\"\n\n    def generate_text_streaming(\n        self,\n        prompt: str,\n        model: str | None = None,\n        max_tokens: int | None = None,\n        temperature: float | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator[str]:\n        \"\"\"Generate text with streaming.\"\"\"\n        # Your implementation here\n        yield \"chunk 1\"\n        yield \"chunk 2\"\n\n    def close(self) -&gt; None:\n        \"\"\"Cleanup resources.\"\"\"\n        # Close connections, etc.\n        pass\n\n# Register and use\nregistry.register_text_provider(\"custom\", MyCustomProvider)\nprovider = registry.get_text_provider(\"custom\")\n</code></pre>"},{"location":"api/providers/#configuration-best-practices","title":"Configuration Best Practices","text":"<ol> <li> <p>Use environment variables for sensitive data:    <pre><code>api_key: ${OPENAI_API_KEY}  # Good\n# api_key: sk-xxxxx  # Bad - don't commit secrets\n</code></pre></p> </li> <li> <p>Set reasonable defaults:    <pre><code>openai:\n  api_key: ${OPENAI_API_KEY}\n  model: gpt-4o\n  max_tokens: 2000  # Reasonable default\n  temperature: 0.7\n</code></pre></p> </li> <li> <p>Use different providers for different tasks:</p> </li> <li>OpenAI GPT-4: Creative writing, complex reasoning</li> <li>Ollama (local): Fast iterations, structured output, development</li> <li>DALL-E: High-quality illustrations</li> <li> <p>Stable Diffusion: Rapid prototyping, style exploration</p> </li> <li> <p>Cache provider instances:    <pre><code># Good - reuses instance\nprovider = registry.get_text_provider()\n\n# Avoid - creates new instances\nfor i in range(100):\n    p = registry.get_text_provider()  # Wasteful\n</code></pre></p> </li> <li> <p>Clean up resources:    <pre><code># Always cleanup when done\nregistry.close_all()\n\n# Or use context managers\nwith registry.get_text_provider() as provider:\n    # Use provider\n    pass\n</code></pre></p> </li> </ol>"},{"location":"api/providers/#see-also","title":"See Also","text":"<ul> <li>Protocol API - Message passing with envelopes</li> <li>State Management API - Project storage</li> <li>Roles API - Role execution with providers</li> </ul>"},{"location":"api/roles_and_loops/","title":"Roles and Loops API Reference","text":"<p>The <code>questfoundry.roles</code> and <code>questfoundry.loops</code> modules provide the role execution and loop orchestration systems. Roles are specialized agents that execute domain-specific tasks using LLM providers. Loops are workflows that coordinate multiple roles to produce and refine artifacts.</p>"},{"location":"api/roles_and_loops/#overview","title":"Overview","text":"<p>Roles are specialized agents with domain expertise: - Load prompts from the spec directory - Execute tasks via configured LLM provider - Produce structured outputs (text, artifacts, metadata)</p> <p>Loops are multi-step workflows that: - Coordinate multiple roles - Manage artifact lifecycles - Implement quality gates - Produce complete work products</p>"},{"location":"api/roles_and_loops/#quick-start","title":"Quick Start","text":""},{"location":"api/roles_and_loops/#using-roles","title":"Using Roles","text":"<pre><code>from questfoundry.roles import RoleRegistry, RoleContext\nfrom questfoundry.providers import ProviderRegistry, ProviderConfig\nfrom questfoundry.models import Artifact\n\n# Setup providers and roles\nprovider_config = ProviderConfig()\nprovider_registry = ProviderRegistry(provider_config)\ntext_provider = provider_registry.get_text_provider()\n\nrole_registry = RoleRegistry(text_provider)\n\n# Get a role\nshowrunner = role_registry.get_role(\"showrunner\")\n\n# Create context\ncontext = RoleContext(\n    task=\"create_initial_hooks\",\n    project_metadata={\"name\": \"Dragon Quest\"},\n    artifacts=[]\n)\n\n# Execute\nresult = showrunner.execute(context)\n\nif result.success:\n    print(f\"Generated {len(result.artifacts)} artifacts\")\n    for artifact in result.artifacts:\n        print(f\"  - {artifact.type}: {artifact.artifact_id}\")\nelse:\n    print(f\"Error: {result.error}\")\n</code></pre>"},{"location":"api/roles_and_loops/#using-loops","title":"Using Loops","text":"<pre><code>from questfoundry.loops import LoopRegistry, LoopContext\nfrom questfoundry.state import WorkspaceManager\n\n# Setup\nws = WorkspaceManager(\"./project\")\nloop_registry = LoopRegistry(role_registry)\n\n# Get loop\nstory_spark = loop_registry.get_loop(\"story_spark\")\n\n# Instantiate required roles\nshowrunner = role_registry.get_role(\"showrunner\")\nlore_weaver = role_registry.get_role(\"lore_weaver\")\n\n# Create context\nloop_context = LoopContext(\n    loop_id=\"story_spark\",\n    project_id=\"dragon-quest\",\n    workspace=ws,\n    role_instances={\"showrunner\": showrunner, \"lore_weaver\": lore_weaver},\n    project_metadata={\"name\": \"Dragon Quest\"}\n)\n\n# Execute loop\nresult = story_spark.execute(loop_context)\n\nif result.success:\n    print(f\"Loop completed: {result.summary}\")\n    print(f\"Artifacts produced: {len(result.artifacts)}\")\nelse:\n    print(f\"Loop failed: {result.error}\")\n</code></pre>"},{"location":"api/roles_and_loops/#roles-module","title":"Roles Module","text":""},{"location":"api/roles_and_loops/#role-abstract-base-class","title":"Role (Abstract Base Class)","text":"<p>Base class for all QuestFoundry roles. Each role is a specialized agent with domain expertise.</p> <p>Abstract Properties: - <code>role_name</code> (str): Role identifier (e.g., \"showrunner\", \"gatekeeper\") - <code>description</code> (str): Human-readable description of role's purpose</p> <p>Constructor:</p> <pre><code>Role(\n    provider: TextProvider,\n    spec_path: Path | None = None,\n    config: dict[str, Any] | None = None\n)\n</code></pre> <p>Parameters: - <code>provider</code>: Text provider for LLM interactions - <code>spec_path</code>: Path to spec directory (default: ./spec) - <code>config</code>: Role-specific configuration</p> <p>Abstract Method:</p>"},{"location":"api/roles_and_loops/#execute","title":"<code>execute()</code>","text":"<pre><code>def execute(context: RoleContext) -&gt; RoleResult\n</code></pre> <p>Execute the role's task based on provided context.</p> <p>Parameters: - <code>context</code>: RoleContext with task and artifacts</p> <p>Returns: RoleResult with output and artifacts</p>"},{"location":"api/roles_and_loops/#rolecontext","title":"RoleContext","text":"<p>Context provided to a role for task execution.</p> <p>Attributes: - <code>task</code> (str): The specific task to execute (e.g., \"generate_hooks\") - <code>artifacts</code> (list[Artifact]): Input artifacts available to the role - <code>project_metadata</code> (dict[str, Any]): Project-level configuration and metadata - <code>workspace_path</code> (Path | None): Path to workspace for file operations - <code>additional_context</code> (dict[str, Any]): Any additional execution context</p> <p>Example: <pre><code>from questfoundry.roles import RoleContext\nfrom pathlib import Path\n\ncontext = RoleContext(\n    task=\"validate_hooks\",\n    artifacts=[hook1, hook2, hook3],\n    project_metadata={\n        \"name\": \"Dragon Quest\",\n        \"genre\": \"fantasy\",\n        \"setting\": \"medieval\"\n    },\n    workspace_path=Path(\"./project\"),\n    additional_context={\"tu_id\": \"TU-2025-11-07-SR01\"}\n)\n</code></pre></p>"},{"location":"api/roles_and_loops/#roleresult","title":"RoleResult","text":"<p>Result of a role execution.</p> <p>Attributes: - <code>success</code> (bool): Whether the task completed successfully - <code>output</code> (str): Primary output from the role (could be text, JSON, etc.) - <code>artifacts</code> (list[Artifact]): Artifacts produced or modified by this role - <code>metadata</code> (dict[str, Any]): Additional metadata about the execution - <code>error</code> (str | None): Error message if success=False</p> <p>Example: <pre><code>result = role.execute(context)\n\nif result.success:\n    print(f\"Output: {result.output}\")\n    print(f\"Produced {len(result.artifacts)} artifacts\")\n    print(f\"Metadata: {result.metadata}\")\nelse:\n    print(f\"Error: {result.error}\")\n</code></pre></p>"},{"location":"api/roles_and_loops/#roleregistry","title":"RoleRegistry","text":"<p>Registry for discovering and instantiating roles.</p> <p>Constructor:</p> <pre><code>RoleRegistry(\n    text_provider: TextProvider,\n    spec_path: Path | None = None\n)\n</code></pre> <p>Parameters: - <code>text_provider</code>: Default text provider for roles - <code>spec_path</code>: Path to spec directory</p> <p>Methods:</p>"},{"location":"api/roles_and_loops/#get_role","title":"<code>get_role()</code>","text":"<pre><code>def get_role(\n    role_name: str,\n    provider: TextProvider | None = None\n) -&gt; Role\n</code></pre> <p>Get or create a role instance.</p> <p>Parameters: - <code>role_name</code>: Role identifier (e.g., \"showrunner\", \"gatekeeper\") - <code>provider</code>: Optional provider override (uses default if None)</p> <p>Returns: Role instance</p> <p>Example: <pre><code>registry = RoleRegistry(text_provider)\n\n# Get roles\nshowrunner = registry.get_role(\"showrunner\")\ngatekeeper = registry.get_role(\"gatekeeper\")\nlore_weaver = registry.get_role(\"lore_weaver\")\n\n# Use custom provider\ncustom_provider = ...\nscene_smith = registry.get_role(\"scene_smith\", provider=custom_provider)\n</code></pre></p>"},{"location":"api/roles_and_loops/#list_roles","title":"<code>list_roles()</code>","text":"<pre><code>def list_roles() -&gt; list[str]\n</code></pre> <p>List all available role names.</p> <p>Example: <pre><code>roles = registry.list_roles()\nprint(f\"Available roles: {roles}\")\n# Output: ['showrunner', 'gatekeeper', 'lore_weaver', 'scene_smith', ...]\n</code></pre></p>"},{"location":"api/roles_and_loops/#available-roles","title":"Available Roles","text":"<p>The following roles are available in the system:</p> <p>Core Orchestration: - showrunner - Loop orchestration and workflow management - gatekeeper - Quality validation and gate checking</p> <p>Content Creation: - lore_weaver - World-building and canon management - scene_smith - Scene writing and narrative development - plotwright - Plot structure and story arcs - codex_curator - Codex entries and encyclopedic content</p> <p>Style and Presentation: - style_lead - Style guide enforcement and consistency</p> <p>Asset Generation: - art_director - Visual direction and art planning - illustrator - Image generation - audio_director - Audio direction and planning - audio_producer - Audio generation</p> <p>Support: - player_narrator - Player-facing content and playtest - book_binder - Export and rendering - researcher - Research and reference gathering - translator - Localization and translation</p>"},{"location":"api/roles_and_loops/#loops-module","title":"Loops Module","text":""},{"location":"api/roles_and_loops/#loop-abstract-base-class","title":"Loop (Abstract Base Class)","text":"<p>Base class for all QuestFoundry loops. Loops are multi-step workflows that coordinate roles.</p> <p>Abstract Properties: - <code>loop_id</code> (str): Loop identifier (e.g., \"story_spark\") - <code>metadata</code> (LoopMetadata): Loop metadata (name, description, etc.)</p> <p>Constructor:</p> <pre><code>Loop(role_registry: RoleRegistry, config: dict[str, Any] | None = None)\n</code></pre> <p>Parameters: - <code>role_registry</code>: Registry for accessing roles - <code>config</code>: Loop-specific configuration</p> <p>Abstract Method:</p>"},{"location":"api/roles_and_loops/#execute_1","title":"<code>execute()</code>","text":"<pre><code>def execute(context: LoopContext) -&gt; LoopResult\n</code></pre> <p>Execute the complete loop workflow.</p> <p>Parameters: - <code>context</code>: LoopContext with workspace and roles</p> <p>Returns: LoopResult with success status and artifacts</p>"},{"location":"api/roles_and_loops/#loopmetadata","title":"LoopMetadata","text":"<p>Metadata about a loop for selection and documentation.</p> <p>Attributes: - <code>loop_id</code> (str): Loop identifier - <code>name</code> (str): Display name - <code>description</code> (str): What the loop accomplishes - <code>primary_roles</code> (list[str]): Roles required for this loop - <code>input_artifact_types</code> (list[str]): Expected input types - <code>output_artifact_types</code> (list[str]): Produced output types - <code>estimated_duration</code> (str): Human-readable duration estimate - <code>complexity</code> (str): \"simple\", \"moderate\", or \"complex\" - <code>prerequisites</code> (list[str]): Required prior loops or conditions</p> <p>Example: <pre><code>metadata = LoopMetadata(\n    loop_id=\"story_spark\",\n    name=\"Story Spark\",\n    description=\"Generate initial story hooks and world foundation\",\n    primary_roles=[\"showrunner\", \"lore_weaver\"],\n    input_artifact_types=[],\n    output_artifact_types=[\"hook_card\", \"canon_pack\"],\n    estimated_duration=\"5-10 minutes\",\n    complexity=\"simple\",\n    prerequisites=[]\n)\n</code></pre></p>"},{"location":"api/roles_and_loops/#loopcontext","title":"LoopContext","text":"<p>Context for active loop execution.</p> <p>Attributes: - <code>loop_id</code> (str): ID of the loop being executed - <code>project_id</code> (str): ID of the project - <code>workspace</code> (WorkspaceManager): Workspace for artifact storage - <code>role_instances</code> (dict[str, Role]): Instantiated role objects keyed by name - <code>artifacts</code> (list[Artifact]): Artifacts available for this loop - <code>project_metadata</code> (dict[str, Any]): Project-level metadata - <code>current_step</code> (int): Index of currently executing step - <code>history</code> (list[dict]): Execution history - <code>config</code> (dict[str, Any]): Loop configuration</p> <p>Example: <pre><code>from questfoundry.loops import LoopContext\n\ncontext = LoopContext(\n    loop_id=\"hook_harvest\",\n    project_id=\"dragon-quest\",\n    workspace=ws,\n    role_instances={\n        \"showrunner\": showrunner,\n        \"lore_weaver\": lore_weaver,\n        \"gatekeeper\": gatekeeper,\n    },\n    artifacts=existing_hooks,\n    project_metadata={\"name\": \"Dragon Quest\", \"genre\": \"fantasy\"},\n    config={\"hook_count\": 10}\n)\n</code></pre></p>"},{"location":"api/roles_and_loops/#loopresult","title":"LoopResult","text":"<p>Result of loop execution.</p> <p>Attributes: - <code>success</code> (bool): Whether loop completed successfully - <code>artifacts</code> (list[Artifact]): Artifacts produced by the loop - <code>summary</code> (str): Human-readable summary of what happened - <code>steps_completed</code> (int): Number of steps successfully completed - <code>total_steps</code> (int): Total number of steps in loop - <code>metadata</code> (dict[str, Any]): Additional execution metadata - <code>error</code> (str | None): Error message if success=False</p> <p>Example: <pre><code>result = loop.execute(context)\n\nprint(f\"Success: {result.success}\")\nprint(f\"Steps: {result.steps_completed}/{result.total_steps}\")\nprint(f\"Summary: {result.summary}\")\nprint(f\"Artifacts: {len(result.artifacts)}\")\n\nif not result.success:\n    print(f\"Error: {result.error}\")\n</code></pre></p>"},{"location":"api/roles_and_loops/#loopstep","title":"LoopStep","text":"<p>Single step in a loop execution.</p> <p>Attributes: - <code>step_id</code> (str): Unique identifier for this step - <code>description</code> (str): What this step does - <code>assigned_roles</code> (list[str]): Roles that perform this step (RACI: Responsible) - <code>consulted_roles</code> (list[str]): Roles that provide input (RACI: Consulted) - <code>informed_roles</code> (list[str]): Roles that receive updates (RACI: Informed) - <code>artifacts_input</code> (list[str]): Required artifact types for input - <code>artifacts_output</code> (list[str]): Expected artifact types to produce - <code>validation_required</code> (bool): Whether validation is required before proceeding - <code>status</code> (StepStatus): Current status (pending, in_progress, completed, failed, skipped) - <code>result</code> (Any | None): Result of executing this step - <code>error</code> (str | None): Error message if step failed</p> <p>Example: <pre><code>from questfoundry.loops import LoopStep, StepStatus\n\nstep = LoopStep(\n    step_id=\"generate_hooks\",\n    description=\"Generate initial story hooks\",\n    assigned_roles=[\"lore_weaver\"],\n    consulted_roles=[\"showrunner\"],\n    informed_roles=[\"gatekeeper\"],\n    artifacts_input=[],\n    artifacts_output=[\"hook_card\"],\n    validation_required=True,\n    status=StepStatus.PENDING\n)\n</code></pre></p>"},{"location":"api/roles_and_loops/#stepstatus-enum","title":"StepStatus (Enum)","text":"<p>Status of a loop step.</p> <p>Values: - <code>PENDING</code> = \"pending\" - <code>IN_PROGRESS</code> = \"in_progress\" - <code>COMPLETED</code> = \"completed\" - <code>FAILED</code> = \"failed\" - <code>SKIPPED</code> = \"skipped\"</p>"},{"location":"api/roles_and_loops/#loopregistry","title":"LoopRegistry","text":"<p>Registry for discovering and instantiating loops.</p> <p>Constructor:</p> <pre><code>LoopRegistry(role_registry: RoleRegistry)\n</code></pre> <p>Parameters: - <code>role_registry</code>: Registry for accessing roles</p> <p>Methods:</p>"},{"location":"api/roles_and_loops/#get_loop","title":"<code>get_loop()</code>","text":"<pre><code>def get_loop(loop_id: str) -&gt; Loop\n</code></pre> <p>Get or create a loop instance.</p> <p>Parameters: - <code>loop_id</code>: Loop identifier (e.g., \"story_spark\")</p> <p>Returns: Loop instance</p> <p>Example: <pre><code>loop_registry = LoopRegistry(role_registry)\n\n# Get loops\nstory_spark = loop_registry.get_loop(\"story_spark\")\nhook_harvest = loop_registry.get_loop(\"hook_harvest\")\nscene_forge = loop_registry.get_loop(\"scene_forge\")\n</code></pre></p>"},{"location":"api/roles_and_loops/#list_loops","title":"<code>list_loops()</code>","text":"<pre><code>def list_loops() -&gt; list[LoopMetadata]\n</code></pre> <p>List all available loops with their metadata.</p> <p>Returns: List of LoopMetadata objects</p> <p>Example: <pre><code>loops = loop_registry.list_loops()\n\nfor meta in loops:\n    print(f\"{meta.name} ({meta.loop_id})\")\n    print(f\"  {meta.description}\")\n    print(f\"  Roles: {', '.join(meta.primary_roles)}\")\n    print(f\"  Duration: {meta.estimated_duration}\")\n    print()\n</code></pre></p>"},{"location":"api/roles_and_loops/#available-loops","title":"Available Loops","text":"<p>Currently Implemented: - story_spark - Generate initial story hooks and world foundation</p> <p>Planned (Have Playbooks): - hook_harvest - Expand and refine story hooks - canon_expansion - Deepen world lore and canon - scene_forge - Write narrative scenes - codex_expansion - Create codex entries - style_tuneup - Refine style consistency - gatecheck - Run quality validation - binding_run - Export and render content - art_touchup - Generate/refine visual assets - audio_pass - Generate audio assets - translation_pass - Localize content - archive_snapshot - Create project snapshots - post_mortem - Retrospective analysis - narration_dryrun - Playtest preparation</p>"},{"location":"api/roles_and_loops/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/roles_and_loops/#complete-role-execution","title":"Complete Role Execution","text":"<pre><code>from questfoundry.roles import RoleRegistry, RoleContext\nfrom questfoundry.providers import ProviderRegistry, ProviderConfig\n\n# Setup\nconfig = ProviderConfig()\nprovider_reg = ProviderRegistry(config)\ntext_provider = provider_reg.get_text_provider(\"openai\")\n\nrole_registry = RoleRegistry(text_provider)\n\n# Get role\nlore_weaver = role_registry.get_role(\"lore_weaver\")\n\n# Create context\ncontext = RoleContext(\n    task=\"create_initial_canon\",\n    project_metadata={\n        \"name\": \"Dragon's Legacy\",\n        \"genre\": \"fantasy\",\n        \"themes\": [\"heroism\", \"sacrifice\", \"redemption\"]\n    }\n)\n\n# Execute\nresult = lore_weaver.execute(context)\n\nif result.success:\n    # Process artifacts\n    for artifact in result.artifacts:\n        if artifact.type == \"canon_pack\":\n            print(f\"Canon: {artifact.data.get('title')}\")\n            # Save to workspace\n            ws.save_hot_artifact(artifact)\nelse:\n    print(f\"Error: {result.error}\")\n</code></pre>"},{"location":"api/roles_and_loops/#complete-loop-execution","title":"Complete Loop Execution","text":"<pre><code>from questfoundry.loops import LoopRegistry, LoopContext\nfrom questfoundry.state import WorkspaceManager\n\n# Setup\nws = WorkspaceManager(\"./dragon-legacy\")\nrole_registry = RoleRegistry(text_provider)\nloop_registry = LoopRegistry(role_registry)\n\n# Get loop\nstory_spark = loop_registry.get_loop(\"story_spark\")\n\n# Prepare roles\nroles = {\n    \"showrunner\": role_registry.get_role(\"showrunner\"),\n    \"lore_weaver\": role_registry.get_role(\"lore_weaver\"),\n    \"gatekeeper\": role_registry.get_role(\"gatekeeper\"),\n}\n\n# Create context\ncontext = LoopContext(\n    loop_id=\"story_spark\",\n    project_id=\"dragon-legacy\",\n    workspace=ws,\n    role_instances=roles,\n    project_metadata={\n        \"name\": \"Dragon's Legacy\",\n        \"genre\": \"fantasy\"\n    }\n)\n\n# Execute\nresult = story_spark.execute(context)\n\nprint(f\"Success: {result.success}\")\nprint(f\"Summary: {result.summary}\")\n\n# Save artifacts\nfor artifact in result.artifacts:\n    ws.save_hot_artifact(artifact)\n\nprint(f\"Generated {len(result.artifacts)} artifacts\")\n</code></pre>"},{"location":"api/roles_and_loops/#multi-role-collaboration","title":"Multi-Role Collaboration","text":"<pre><code># Setup roles\nroles = {\n    \"lore_weaver\": role_registry.get_role(\"lore_weaver\"),\n    \"scene_smith\": role_registry.get_role(\"scene_smith\"),\n    \"gatekeeper\": role_registry.get_role(\"gatekeeper\"),\n}\n\n# Step 1: Lore Weaver creates canon\nlw_context = RoleContext(\n    task=\"create_canon\",\n    project_metadata={\"name\": \"Quest\"}\n)\nlw_result = roles[\"lore_weaver\"].execute(lw_context)\n\n# Step 2: Scene Smith uses canon\nss_context = RoleContext(\n    task=\"write_scene\",\n    artifacts=lw_result.artifacts,  # Canon from lore weaver\n    project_metadata={\"name\": \"Quest\"}\n)\nss_result = roles[\"scene_smith\"].execute(ss_context)\n\n# Step 3: Gatekeeper validates\ngk_context = RoleContext(\n    task=\"validate\",\n    artifacts=ss_result.artifacts,  # Scene from scene smith\n    project_metadata={\"name\": \"Quest\"}\n)\ngk_result = roles[\"gatekeeper\"].execute(gk_context)\n\nif gk_result.success:\n    # Validation passed, promote to cold\n    for artifact in ss_result.artifacts:\n        ws.promote_to_cold(artifact.artifact_id)\n</code></pre>"},{"location":"api/roles_and_loops/#custom-loop-steps","title":"Custom Loop Steps","text":"<pre><code>from questfoundry.loops import LoopStep, StepStatus\n\n# Define custom loop steps\nsteps = [\n    LoopStep(\n        step_id=\"brainstorm\",\n        description=\"Brainstorm initial concepts\",\n        assigned_roles=[\"lore_weaver\"],\n        artifacts_output=[\"hook_card\"],\n    ),\n    LoopStep(\n        step_id=\"validate\",\n        description=\"Validate concepts\",\n        assigned_roles=[\"gatekeeper\"],\n        consulted_roles=[\"lore_weaver\"],\n        artifacts_input=[\"hook_card\"],\n        artifacts_output=[\"gatecheck_report\"],\n        validation_required=True,\n    ),\n    LoopStep(\n        step_id=\"refine\",\n        description=\"Refine approved concepts\",\n        assigned_roles=[\"lore_weaver\"],\n        artifacts_input=[\"hook_card\", \"gatecheck_report\"],\n        artifacts_output=[\"hook_card\"],\n    ),\n]\n\n# Execute steps sequentially\nfor step in steps:\n    step.status = StepStatus.IN_PROGRESS\n    try:\n        # Execute step logic\n        # ...\n        step.status = StepStatus.COMPLETED\n    except Exception as e:\n        step.status = StepStatus.FAILED\n        step.error = str(e)\n        break\n</code></pre>"},{"location":"api/roles_and_loops/#error-handling","title":"Error Handling","text":"<pre><code># Role execution with error handling\ntry:\n    result = role.execute(context)\n\n    if not result.success:\n        # Handle role failure\n        print(f\"Role failed: {result.error}\")\n        # Log for review\n        # Retry with modified context\n        # Or escalate to human\n    else:\n        # Process success\n        pass\n\nexcept Exception as e:\n    # Handle unexpected errors\n    print(f\"Unexpected error: {e}\")\n    # Log exception\n    # Clean up resources\n</code></pre>"},{"location":"api/roles_and_loops/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use role registry for role instantiation:    <pre><code># Good - managed instances\nrole = role_registry.get_role(\"showrunner\")\n\n# Avoid - manual instantiation\nrole = ShowrunnerRole(provider)\n</code></pre></p> </li> <li> <p>Provide complete context:    <pre><code>context = RoleContext(\n    task=\"clear_task_description\",\n    artifacts=relevant_artifacts,  # Only what's needed\n    project_metadata=full_metadata,  # All project info\n    additional_context={\"tu_id\": \"...\"}  # Extra details\n)\n</code></pre></p> </li> <li> <p>Check results before proceeding:    <pre><code>result = role.execute(context)\nif not result.success:\n    # Handle error before continuing\n    return\n\n# Now safe to use result.artifacts\n</code></pre></p> </li> <li> <p>Use loops for complex workflows:    <pre><code># Good - coordinated workflow\nloop = loop_registry.get_loop(\"story_spark\")\nresult = loop.execute(context)\n\n# Avoid - manual coordination\nrole1.execute(...)\nrole2.execute(...)\n# ... error-prone\n</code></pre></p> </li> <li> <p>Save artifacts promptly:    <pre><code>result = role.execute(context)\nfor artifact in result.artifacts:\n    ws.save_hot_artifact(artifact)  # Save immediately\n</code></pre></p> </li> <li> <p>Cache role instances:    <pre><code># Good - reuse instances\nroles = {\n    name: role_registry.get_role(name)\n    for name in [\"showrunner\", \"lore_weaver\", \"gatekeeper\"]\n}\n\n# Use throughout session\nroles[\"lore_weaver\"].execute(...)\n</code></pre></p> </li> </ol>"},{"location":"api/roles_and_loops/#see-also","title":"See Also","text":"<ul> <li>Provider API - LLM provider configuration</li> <li>State Management API - Workspace and artifacts</li> <li>Validation API - Quality gates</li> </ul>"},{"location":"api/state/","title":"State Management API Reference","text":"<p>The <code>questfoundry.state</code> module provides state persistence for QuestFoundry projects, implementing both hot workspace (file-based) and cold storage (SQLite) with the hot/cold Source of Truth pattern.</p>"},{"location":"api/state/#overview","title":"Overview","text":"<p>QuestFoundry uses a dual-storage architecture:</p> <ul> <li>Hot Workspace (<code>.questfoundry/hot/</code>) - File-based, human-readable, work-in-progress</li> <li>Cold Storage (<code>project.qfproj</code>) - SQLite database, curated, stable snapshots</li> </ul> <p>The state management module provides:</p> <ul> <li>WorkspaceManager: Unified interface for hot and cold storage</li> <li>SQLiteStore: Cold storage implementation (.qfproj files)</li> <li>FileStore: Hot workspace implementation (directory structure)</li> <li>StateStore: Abstract interface for storage backends</li> <li>Data Models: ProjectInfo, TUState, SnapshotInfo</li> </ul>"},{"location":"api/state/#quick-start","title":"Quick Start","text":"<pre><code>from questfoundry.state import WorkspaceManager\nfrom questfoundry.models import Artifact\n\n# Initialize workspace\nws = WorkspaceManager(\"/path/to/project\")\nws.init_workspace(\n    name=\"Dragon Quest\",\n    description=\"Epic fantasy adventure\",\n    author=\"Alice\"\n)\n\n# Create and save hot artifact\nartifact = Artifact(\n    type=\"hook_card\",\n    data={\n        \"hook_id\": \"HOOK-001\",\n        \"title\": \"The Dragon's Lair\",\n        \"concept\": \"Ancient dragon hoarding magical artifacts\"\n    },\n    metadata={\"temperature\": \"hot\", \"status\": \"draft\"}\n)\nws.save_hot_artifact(artifact)\n\n# Promote to cold storage when ready\nws.promote_to_cold(\"HOOK-001\")\n\n# Query artifacts\nhooks = ws.list_cold_artifacts(\"hook_card\")\nprint(f\"Found {len(hooks)} hooks in cold storage\")\n</code></pre>"},{"location":"api/state/#workspacemanager","title":"WorkspaceManager","text":"<p>Unified manager for QuestFoundry workspace with both hot and cold storage.</p>"},{"location":"api/state/#constructor","title":"Constructor","text":"<pre><code>WorkspaceManager(project_dir: str | Path)\n</code></pre> <p>Parameters: - <code>project_dir</code>: Path to project directory</p> <p>Directory Structure Created: <pre><code>project_dir/\n  .questfoundry/\n    hot/\n      hooks/\n      canon/\n      tus/\n      snapshots/\n    metadata.json\n  project.qfproj  # SQLite database\n</code></pre></p> <p>Example: <pre><code>from questfoundry.state import WorkspaceManager\n\nws = WorkspaceManager(\"./my-adventure\")\n</code></pre></p>"},{"location":"api/state/#workspace-initialization","title":"Workspace Initialization","text":""},{"location":"api/state/#init_workspace","title":"<code>init_workspace()</code>","text":"<pre><code>def init_workspace(\n    self,\n    name: str,\n    description: str = \"\",\n    version: str = \"1.0.0\",\n    author: str | None = None,\n) -&gt; None\n</code></pre> <p>Initialize a new workspace with hot and cold storage. Creates directory structure and initializes both stores with project metadata.</p> <p>Parameters: - <code>name</code>: Project name - <code>description</code>: Project description (optional) - <code>version</code>: Project version (default: \"1.0.0\") - <code>author</code>: Project author (optional)</p> <p>Example: <pre><code>ws = WorkspaceManager(\"./dragon-quest\")\nws.init_workspace(\n    name=\"Dragon Quest\",\n    description=\"An epic fantasy adventure\",\n    version=\"0.1.0\",\n    author=\"Alice Smith\"\n)\n</code></pre></p>"},{"location":"api/state/#project-information","title":"Project Information","text":""},{"location":"api/state/#get_project_info","title":"<code>get_project_info()</code>","text":"<pre><code>def get_project_info(self, source: str = \"hot\") -&gt; ProjectInfo\n</code></pre> <p>Get project information from hot or cold storage.</p> <p>Parameters: - <code>source</code>: Storage source - \"hot\" or \"cold\" (default: \"hot\")</p> <p>Returns: ProjectInfo object</p> <p>Raises: - <code>ValueError</code>: If source is invalid - <code>FileNotFoundError</code>: If project metadata not found</p> <p>Example: <pre><code># Get from hot workspace\ninfo = ws.get_project_info(\"hot\")\nprint(f\"Project: {info.name}, Version: {info.version}\")\n\n# Get from cold storage\ncold_info = ws.get_project_info(\"cold\")\n</code></pre></p>"},{"location":"api/state/#save_project_info","title":"<code>save_project_info()</code>","text":"<pre><code>def save_project_info(\n    self,\n    info: ProjectInfo,\n    target: str = \"both\"\n) -&gt; None\n</code></pre> <p>Save project information to hot, cold, or both storages.</p> <p>Parameters: - <code>info</code>: ProjectInfo instance to save - <code>target</code>: Where to save - \"hot\", \"cold\", or \"both\" (default: \"both\")</p> <p>Raises: - <code>ValueError</code>: If target is invalid</p> <p>Example: <pre><code>from questfoundry.state import ProjectInfo\n\ninfo = ws.get_project_info()\ninfo.version = \"0.2.0\"\ninfo.description = \"Updated description\"\nws.save_project_info(info, target=\"both\")\n</code></pre></p>"},{"location":"api/state/#hot-workspace-operations","title":"Hot Workspace Operations","text":"<p>Hot workspace contains work-in-progress artifacts that are actively being edited and reviewed.</p>"},{"location":"api/state/#save_hot_artifact","title":"<code>save_hot_artifact()</code>","text":"<pre><code>def save_hot_artifact(self, artifact: Artifact) -&gt; None\n</code></pre> <p>Save artifact to hot workspace.</p> <p>Parameters: - <code>artifact</code>: Artifact instance to save</p> <p>Example: <pre><code>artifact = Artifact(\n    type=\"hook_card\",\n    data={\"hook_id\": \"HOOK-001\", \"title\": \"Dragon Awakens\"},\n    metadata={\"temperature\": \"hot\", \"status\": \"draft\"}\n)\nws.save_hot_artifact(artifact)\n</code></pre></p>"},{"location":"api/state/#get_hot_artifact","title":"<code>get_hot_artifact()</code>","text":"<pre><code>def get_hot_artifact(self, artifact_id: str) -&gt; Artifact | None\n</code></pre> <p>Get artifact from hot workspace.</p> <p>Parameters: - <code>artifact_id</code>: Unique artifact identifier</p> <p>Returns: Artifact if found, None otherwise</p> <p>Example: <pre><code>artifact = ws.get_hot_artifact(\"HOOK-001\")\nif artifact:\n    print(f\"Title: {artifact.data['title']}\")\n</code></pre></p>"},{"location":"api/state/#list_hot_artifacts","title":"<code>list_hot_artifacts()</code>","text":"<pre><code>def list_hot_artifacts(\n    self,\n    artifact_type: str | None = None,\n    filters: dict[str, Any] | None = None,\n) -&gt; list[Artifact]\n</code></pre> <p>List artifacts in hot workspace with optional filtering.</p> <p>Parameters: - <code>artifact_type</code>: Filter by type (e.g., \"hook_card\"), None for all types - <code>filters</code>: Additional filters as key-value pairs</p> <p>Returns: List of matching artifacts</p> <p>Example: <pre><code># List all hot hooks\nhooks = ws.list_hot_artifacts(\"hook_card\")\n\n# List draft hooks\ndrafts = ws.list_hot_artifacts(\n    \"hook_card\",\n    {\"status\": \"draft\"}\n)\n\n# List all hot artifacts\nall_hot = ws.list_hot_artifacts()\n</code></pre></p>"},{"location":"api/state/#delete_hot_artifact","title":"<code>delete_hot_artifact()</code>","text":"<pre><code>def delete_hot_artifact(self, artifact_id: str) -&gt; bool\n</code></pre> <p>Delete artifact from hot workspace.</p> <p>Parameters: - <code>artifact_id</code>: Unique artifact identifier</p> <p>Returns: True if deleted, False if not found</p> <p>Example: <pre><code>if ws.delete_hot_artifact(\"HOOK-001\"):\n    print(\"Artifact deleted\")\nelse:\n    print(\"Artifact not found\")\n</code></pre></p>"},{"location":"api/state/#cold-storage-operations","title":"Cold Storage Operations","text":"<p>Cold storage contains curated, stable artifacts that have been reviewed and promoted from hot workspace.</p>"},{"location":"api/state/#save_cold_artifact","title":"<code>save_cold_artifact()</code>","text":"<pre><code>def save_cold_artifact(self, artifact: Artifact) -&gt; None\n</code></pre> <p>Save artifact to cold storage.</p> <p>Parameters: - <code>artifact</code>: Artifact instance to save</p> <p>Example: <pre><code>artifact = Artifact(\n    type=\"hook_card\",\n    data={\"hook_id\": \"HOOK-001\", \"title\": \"Dragon Awakens\"},\n    metadata={\"temperature\": \"cold\", \"status\": \"approved\"}\n)\nws.save_cold_artifact(artifact)\n</code></pre></p>"},{"location":"api/state/#get_cold_artifact","title":"<code>get_cold_artifact()</code>","text":"<pre><code>def get_cold_artifact(self, artifact_id: str) -&gt; Artifact | None\n</code></pre> <p>Get artifact from cold storage.</p> <p>Parameters: - <code>artifact_id</code>: Unique artifact identifier</p> <p>Returns: Artifact if found, None otherwise</p> <p>Example: <pre><code>artifact = ws.get_cold_artifact(\"HOOK-001\")\nif artifact:\n    print(f\"Curated hook: {artifact.data['title']}\")\n</code></pre></p>"},{"location":"api/state/#list_cold_artifacts","title":"<code>list_cold_artifacts()</code>","text":"<pre><code>def list_cold_artifacts(\n    self,\n    artifact_type: str | None = None,\n    filters: dict[str, Any] | None = None,\n) -&gt; list[Artifact]\n</code></pre> <p>List artifacts in cold storage with optional filtering.</p> <p>Parameters: - <code>artifact_type</code>: Filter by type (e.g., \"hook_card\"), None for all types - <code>filters</code>: Additional filters as key-value pairs</p> <p>Returns: List of matching artifacts</p> <p>Example: <pre><code># List all cold hooks\nhooks = ws.list_cold_artifacts(\"hook_card\")\n\n# List approved canon\ncanon = ws.list_cold_artifacts(\n    \"canon_pack\",\n    {\"status\": \"approved\"}\n)\n</code></pre></p>"},{"location":"api/state/#delete_cold_artifact","title":"<code>delete_cold_artifact()</code>","text":"<pre><code>def delete_cold_artifact(self, artifact_id: str) -&gt; bool\n</code></pre> <p>Delete artifact from cold storage.</p> <p>Parameters: - <code>artifact_id</code>: Unique artifact identifier</p> <p>Returns: True if deleted, False if not found</p> <p>Example: <pre><code>if ws.delete_cold_artifact(\"HOOK-001\"):\n    print(\"Artifact removed from cold storage\")\n</code></pre></p>"},{"location":"api/state/#promotion-operations","title":"Promotion Operations","text":"<p>Move artifacts between hot workspace and cold storage.</p>"},{"location":"api/state/#promote_to_cold","title":"<code>promote_to_cold()</code>","text":"<pre><code>def promote_to_cold(\n    self,\n    artifact_id: str,\n    delete_hot: bool = True\n) -&gt; bool\n</code></pre> <p>Promote artifact from hot workspace to cold storage. This is the primary workflow for curating content.</p> <p>Parameters: - <code>artifact_id</code>: ID of artifact to promote - <code>delete_hot</code>: Whether to delete from hot workspace after promotion (default: True)</p> <p>Returns: True if promotion succeeded, False if artifact not found</p> <p>Example: <pre><code># Promote and remove from hot\nif ws.promote_to_cold(\"HOOK-001\"):\n    print(\"Hook promoted to cold storage\")\n\n# Promote but keep in hot (for comparison)\nws.promote_to_cold(\"HOOK-002\", delete_hot=False)\n</code></pre></p>"},{"location":"api/state/#demote_to_hot","title":"<code>demote_to_hot()</code>","text":"<pre><code>def demote_to_hot(\n    self,\n    artifact_id: str,\n    delete_cold: bool = False\n) -&gt; bool\n</code></pre> <p>Demote artifact from cold storage to hot workspace. Useful for revisions.</p> <p>Parameters: - <code>artifact_id</code>: ID of artifact to demote - <code>delete_cold</code>: Whether to delete from cold storage after demotion (default: False)</p> <p>Returns: True if demotion succeeded, False if artifact not found</p> <p>Example: <pre><code># Copy back to hot for editing\nif ws.demote_to_hot(\"HOOK-001\"):\n    print(\"Hook available for editing in hot workspace\")\n\n# Move to hot and remove from cold\nws.demote_to_hot(\"HOOK-002\", delete_cold=True)\n</code></pre></p>"},{"location":"api/state/#thematic-unit-tu-operations","title":"Thematic Unit (TU) Operations","text":"<p>TUs are tracked in hot workspace only, representing active work units.</p>"},{"location":"api/state/#save_tu","title":"<code>save_tu()</code>","text":"<pre><code>def save_tu(self, tu: TUState) -&gt; None\n</code></pre> <p>Save TU state to hot workspace.</p> <p>Parameters: - <code>tu</code>: TUState instance</p> <p>Example: <pre><code>from questfoundry.state import TUState\n\ntu = TUState(\n    tu_id=\"TU-2025-11-07-SR01\",\n    status=\"in_progress\",\n    data={\"brief\": \"Opening scene development\"},\n    metadata={\"loop\": \"scene_forge\"}\n)\nws.save_tu(tu)\n</code></pre></p>"},{"location":"api/state/#get_tu","title":"<code>get_tu()</code>","text":"<pre><code>def get_tu(self, tu_id: str) -&gt; TUState | None\n</code></pre> <p>Get TU state from hot workspace.</p> <p>Parameters: - <code>tu_id</code>: TU identifier (e.g., \"TU-2025-11-07-SR01\")</p> <p>Returns: TUState if found, None otherwise</p> <p>Example: <pre><code>tu = ws.get_tu(\"TU-2025-11-07-SR01\")\nif tu:\n    print(f\"TU Status: {tu.status}\")\n    print(f\"Created: {tu.created}\")\n</code></pre></p>"},{"location":"api/state/#list_tus","title":"<code>list_tus()</code>","text":"<pre><code>def list_tus(\n    self,\n    filters: dict[str, Any] | None = None\n) -&gt; list[TUState]\n</code></pre> <p>List TUs in hot workspace with optional filtering.</p> <p>Parameters: - <code>filters</code>: Filters as key-value pairs (e.g., <code>{\"status\": \"open\"}</code>)</p> <p>Returns: List of matching TUs</p> <p>Example: <pre><code># List all TUs\nall_tus = ws.list_tus()\n\n# List active TUs\nactive = ws.list_tus({\"status\": \"in_progress\"})\n\n# List TUs for specific snapshot\nsnapshot_tus = ws.list_tus({\"snapshot_id\": \"SNAP-001\"})\n</code></pre></p>"},{"location":"api/state/#snapshot-operations","title":"Snapshot Operations","text":"<p>Snapshots represent points-in-time captures of project state.</p>"},{"location":"api/state/#save_snapshot","title":"<code>save_snapshot()</code>","text":"<pre><code>def save_snapshot(\n    self,\n    snapshot: SnapshotInfo,\n    target: str = \"both\"\n) -&gt; None\n</code></pre> <p>Save snapshot metadata to hot, cold, or both storages.</p> <p>Parameters: - <code>snapshot</code>: SnapshotInfo instance - <code>target</code>: Where to save - \"hot\", \"cold\", or \"both\" (default: \"both\")</p> <p>Raises: - <code>ValueError</code>: If target is invalid or snapshot already exists</p> <p>Example: <pre><code>from questfoundry.state import SnapshotInfo\nfrom datetime import datetime\n\nsnapshot = SnapshotInfo(\n    snapshot_id=\"SNAP-2025-11-07\",\n    tu_id=\"TU-2025-11-07-SR01\",\n    description=\"Chapter 1 complete\",\n    metadata={\"chapter\": 1, \"scene_count\": 5}\n)\nws.save_snapshot(snapshot, target=\"both\")\n</code></pre></p>"},{"location":"api/state/#get_snapshot","title":"<code>get_snapshot()</code>","text":"<pre><code>def get_snapshot(\n    self,\n    snapshot_id: str,\n    source: str = \"hot\"\n) -&gt; SnapshotInfo | None\n</code></pre> <p>Get snapshot metadata from hot or cold storage.</p> <p>Parameters: - <code>snapshot_id</code>: Snapshot identifier - <code>source</code>: Storage source - \"hot\" or \"cold\" (default: \"hot\")</p> <p>Returns: SnapshotInfo or None if not found</p> <p>Raises: - <code>ValueError</code>: If source is invalid</p> <p>Example: <pre><code># Get from hot\nsnapshot = ws.get_snapshot(\"SNAP-2025-11-07\", source=\"hot\")\nif snapshot:\n    print(f\"Snapshot: {snapshot.description}\")\n\n# Get from cold\ncold_snap = ws.get_snapshot(\"SNAP-2025-11-07\", source=\"cold\")\n</code></pre></p>"},{"location":"api/state/#list_snapshots","title":"<code>list_snapshots()</code>","text":"<pre><code>def list_snapshots(\n    self,\n    filters: dict[str, Any] | None = None,\n    source: str = \"hot\"\n) -&gt; list[SnapshotInfo]\n</code></pre> <p>List snapshots from hot or cold storage.</p> <p>Parameters: - <code>filters</code>: Optional filters (e.g., <code>{\"tu_id\": \"TU-001\"}</code>) - <code>source</code>: Storage source - \"hot\" or \"cold\" (default: \"hot\")</p> <p>Returns: List of SnapshotInfo objects</p> <p>Raises: - <code>ValueError</code>: If source is invalid</p> <p>Example: <pre><code># List all hot snapshots\nhot_snapshots = ws.list_snapshots(source=\"hot\")\n\n# List snapshots for specific TU\ntu_snapshots = ws.list_snapshots(\n    filters={\"tu_id\": \"TU-2025-11-07-SR01\"},\n    source=\"cold\"\n)\n</code></pre></p>"},{"location":"api/state/#context-manager-support","title":"Context Manager Support","text":"<p>WorkspaceManager supports Python's context manager protocol for automatic resource cleanup:</p> <pre><code>with WorkspaceManager(\"./my-project\") as ws:\n    ws.init_workspace(\"My Project\")\n    artifact = Artifact(...)\n    ws.save_hot_artifact(artifact)\n# Database connections automatically closed\n</code></pre>"},{"location":"api/state/#methods","title":"Methods","text":""},{"location":"api/state/#close","title":"<code>close()</code>","text":"<pre><code>def close() -&gt; None\n</code></pre> <p>Close database connections and release resources.</p> <p>Example: <pre><code>ws = WorkspaceManager(\"./project\")\ntry:\n    # ... use workspace ...\nfinally:\n    ws.close()\n</code></pre></p>"},{"location":"api/state/#statestore-abstract-interface","title":"StateStore (Abstract Interface)","text":"<p>Abstract base class defining the interface for state persistence backends.</p>"},{"location":"api/state/#abstract-methods","title":"Abstract Methods","text":"<p>All StateStore implementations must provide these methods:</p> <ul> <li><code>get_project_info() -&gt; ProjectInfo</code></li> <li><code>save_project_info(info: ProjectInfo) -&gt; None</code></li> <li><code>save_artifact(artifact: Artifact) -&gt; None</code></li> <li><code>get_artifact(artifact_id: str) -&gt; Artifact | None</code></li> <li><code>list_artifacts(artifact_type, filters) -&gt; list[Artifact]</code></li> <li><code>delete_artifact(artifact_id: str) -&gt; bool</code></li> <li><code>save_tu(tu: TUState) -&gt; None</code></li> <li><code>get_tu(tu_id: str) -&gt; TUState | None</code></li> <li><code>list_tus(filters) -&gt; list[TUState]</code></li> <li><code>save_snapshot(snapshot: SnapshotInfo) -&gt; None</code></li> <li><code>get_snapshot(snapshot_id: str) -&gt; SnapshotInfo | None</code></li> <li><code>list_snapshots(filters) -&gt; list[SnapshotInfo]</code></li> </ul>"},{"location":"api/state/#sqlitestore","title":"SQLiteStore","text":"<p>Cold storage implementation using SQLite database (.qfproj files).</p>"},{"location":"api/state/#constructor_1","title":"Constructor","text":"<pre><code>SQLiteStore(db_path: Path | str)\n</code></pre> <p>Parameters: - <code>db_path</code>: Path to SQLite database file</p> <p>Example: <pre><code>from questfoundry.state import SQLiteStore\n\nstore = SQLiteStore(\"./project.qfproj\")\n</code></pre></p>"},{"location":"api/state/#additional-methods","title":"Additional Methods","text":"<p>In addition to StateStore interface:</p>"},{"location":"api/state/#init_database","title":"<code>init_database()</code>","text":"<pre><code>def init_database() -&gt; None\n</code></pre> <p>Initialize database schema. Creates tables if they don't exist.</p> <p>Example: <pre><code>store = SQLiteStore(\"./new-project.qfproj\")\nstore.init_database()\n</code></pre></p>"},{"location":"api/state/#get_artifacts_by_ids-batch-query","title":"<code>get_artifacts_by_ids()</code> (Batch Query)","text":"<pre><code>def get_artifacts_by_ids(\n    self,\n    artifact_ids: list[str]\n) -&gt; list[Artifact]\n</code></pre> <p>Get multiple artifacts by IDs in a single query. More efficient than multiple <code>get_artifact()</code> calls.</p> <p>Parameters: - <code>artifact_ids</code>: List of artifact IDs to fetch</p> <p>Returns: List of Artifact objects (may be shorter if some IDs not found)</p> <p>Example: <pre><code># Efficient batch fetch\nartifacts = store.get_artifacts_by_ids([\n    \"HOOK-001\",\n    \"HOOK-002\",\n    \"HOOK-003\"\n])\n</code></pre></p>"},{"location":"api/state/#get_artifacts_by_snapshot_id","title":"<code>get_artifacts_by_snapshot_id()</code>","text":"<pre><code>def get_artifacts_by_snapshot_id(\n    self,\n    snapshot_id: str\n) -&gt; list[Artifact]\n</code></pre> <p>Get all artifacts associated with a snapshot.</p> <p>Parameters: - <code>snapshot_id</code>: Snapshot identifier</p> <p>Returns: List of artifacts in this snapshot</p> <p>Example: <pre><code>snapshot_artifacts = store.get_artifacts_by_snapshot_id(\"SNAP-2025-11-07\")\nprint(f\"Snapshot contains {len(snapshot_artifacts)} artifacts\")\n</code></pre></p>"},{"location":"api/state/#save_or_replace_snapshot","title":"<code>save_or_replace_snapshot()</code>","text":"<pre><code>def save_or_replace_snapshot(\n    self,\n    snapshot: SnapshotInfo\n) -&gt; None\n</code></pre> <p>Save or replace snapshot metadata. Used for import operations.</p> <p>Parameters: - <code>snapshot</code>: SnapshotInfo to save/replace</p> <p>Example: <pre><code># Import snapshot (replaces if exists)\nstore.save_or_replace_snapshot(imported_snapshot)\n</code></pre></p>"},{"location":"api/state/#filestore","title":"FileStore","text":"<p>Hot workspace implementation using file-based directory structure.</p>"},{"location":"api/state/#constructor_2","title":"Constructor","text":"<pre><code>FileStore(base_dir: Path | str)\n</code></pre> <p>Parameters: - <code>base_dir</code>: Path to hot workspace directory (typically <code>.questfoundry/</code>)</p> <p>Example: <pre><code>from questfoundry.state import FileStore\n\nstore = FileStore(\"./.questfoundry\")\n</code></pre></p> <p>Files are stored as JSON in subdirectories by artifact type: <pre><code>.questfoundry/\n  hot/\n    hooks/\n      HOOK-001.json\n      HOOK-002.json\n    canon/\n      CANON-001.json\n    tus/\n      TU-2025-11-07-SR01.json\n  metadata.json\n</code></pre></p>"},{"location":"api/state/#data-models","title":"Data Models","text":""},{"location":"api/state/#projectinfo","title":"ProjectInfo","text":"<p>Project metadata and configuration.</p> <p>Fields: - <code>name</code> (str): Project name - <code>description</code> (str): Project description (default: \"\") - <code>created</code> (datetime): Creation timestamp (auto-generated) - <code>modified</code> (datetime): Last modification timestamp (auto-updated) - <code>version</code> (str): Project version (default: \"1.0.0\") - <code>author</code> (str | None): Project author (optional) - <code>metadata</code> (dict[str, Any]): Additional metadata (default: {})</p> <p>Example: <pre><code>from questfoundry.state import ProjectInfo\n\ninfo = ProjectInfo(\n    name=\"Dragon Quest\",\n    description=\"Epic fantasy adventure\",\n    version=\"0.1.0\",\n    author=\"Alice Smith\",\n    metadata={\"genre\": \"fantasy\", \"target_age\": \"adult\"}\n)\n</code></pre></p>"},{"location":"api/state/#tustate","title":"TUState","text":"<p>Thematic Unit state tracking.</p> <p>Fields: - <code>tu_id</code> (str): TU identifier (format: \"TU-YYYY-MM-DD-ROLEXX\") - <code>status</code> (str): TU status (\"open\", \"in_progress\", \"completed\", etc.) - <code>created</code> (datetime): Creation timestamp (auto-generated) - <code>modified</code> (datetime): Last modification timestamp (auto-updated) - <code>snapshot_id</code> (str | None): Associated snapshot ID (optional) - <code>data</code> (dict[str, Any]): TU brief data (default: {}) - <code>metadata</code> (dict[str, Any]): Additional metadata (default: {})</p> <p>Example: <pre><code>from questfoundry.state import TUState\n\ntu = TUState(\n    tu_id=\"TU-2025-11-07-SR01\",\n    status=\"in_progress\",\n    snapshot_id=\"SNAP-001\",\n    data={\n        \"brief\": \"Develop opening scene\",\n        \"assigned_role\": \"SS\"\n    },\n    metadata={\"priority\": \"high\", \"loop\": \"scene_forge\"}\n)\n</code></pre></p>"},{"location":"api/state/#snapshotinfo","title":"SnapshotInfo","text":"<p>Snapshot metadata.</p> <p>Fields: - <code>snapshot_id</code> (str): Snapshot identifier - <code>created</code> (datetime): Creation timestamp (auto-generated) - <code>tu_id</code> (str): Associated TU ID - <code>description</code> (str): Snapshot description (default: \"\") - <code>metadata</code> (dict[str, Any]): Additional metadata (default: {})</p> <p>Example: <pre><code>from questfoundry.state import SnapshotInfo\n\nsnapshot = SnapshotInfo(\n    snapshot_id=\"SNAP-2025-11-07-001\",\n    tu_id=\"TU-2025-11-07-SR01\",\n    description=\"Chapter 1 complete - 5 scenes reviewed and approved\",\n    metadata={\n        \"chapter\": 1,\n        \"scene_count\": 5,\n        \"word_count\": 12500,\n        \"reviewers\": [\"Alice\", \"Bob\"]\n    }\n)\n</code></pre></p>"},{"location":"api/state/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/state/#complete-workflow-example","title":"Complete Workflow Example","text":"<pre><code>from questfoundry.state import WorkspaceManager\nfrom questfoundry.models import Artifact\n\n# 1. Initialize workspace\nwith WorkspaceManager(\"./dragon-quest\") as ws:\n    ws.init_workspace(\n        name=\"Dragon Quest\",\n        description=\"Epic fantasy RPG\",\n        author=\"Alice\"\n    )\n\n    # 2. Create draft hook in hot workspace\n    hook = Artifact(\n        type=\"hook_card\",\n        data={\n            \"hook_id\": \"HOOK-001\",\n            \"title\": \"Dragon's Awakening\",\n            \"concept\": \"Ancient dragon stirs after 1000 years\",\n            \"status\": \"draft\"\n        },\n        metadata={\"temperature\": \"hot\"}\n    )\n    ws.save_hot_artifact(hook)\n\n    # 3. Review and iterate in hot workspace\n    hook = ws.get_hot_artifact(\"HOOK-001\")\n    hook.data[\"concept\"] += \" - adds backstory\"\n    hook.data[\"status\"] = \"reviewed\"\n    ws.save_hot_artifact(hook)\n\n    # 4. Promote to cold when approved\n    ws.promote_to_cold(\"HOOK-001\")\n\n    # 5. Create snapshot\n    from questfoundry.state import SnapshotInfo, TUState\n\n    tu = TUState(\n        tu_id=\"TU-2025-11-07-SR01\",\n        status=\"completed\",\n        data={\"brief\": \"Initial hook development\"}\n    )\n    ws.save_tu(tu)\n\n    snapshot = SnapshotInfo(\n        snapshot_id=\"SNAP-001\",\n        tu_id=\"TU-2025-11-07-SR01\",\n        description=\"First hook complete\"\n    )\n    ws.save_snapshot(snapshot)\n\n    # 6. Query final state\n    cold_hooks = ws.list_cold_artifacts(\"hook_card\")\n    print(f\"Project has {len(cold_hooks)} approved hooks\")\n</code></pre>"},{"location":"api/state/#bulk-operations","title":"Bulk Operations","text":"<pre><code># Promote multiple artifacts\nhot_hooks = ws.list_hot_artifacts(\"hook_card\", {\"status\": \"approved\"})\nfor hook in hot_hooks:\n    hook_id = hook.data.get(\"hook_id\")\n    if hook_id:\n        ws.promote_to_cold(hook_id)\n\n# Batch query with SQLiteStore\nhook_ids = [f\"HOOK-{i:03d}\" for i in range(1, 51)]\nhooks = ws.cold_store.get_artifacts_by_ids(hook_ids)\nprint(f\"Retrieved {len(hooks)} hooks in single query\")\n</code></pre>"},{"location":"api/state/#filtering-and-queries","title":"Filtering and Queries","text":"<pre><code># Complex filtering\nrecent_hooks = ws.list_cold_artifacts(\n    \"hook_card\",\n    {\"status\": \"approved\", \"author\": \"Alice\"}\n)\n\n# Query by TU\ntu_artifacts = ws.list_hot_artifacts(\n    filters={\"tu_id\": \"TU-2025-11-07-SR01\"}\n)\n\n# List active work\nactive_tus = ws.list_tus({\"status\": \"in_progress\"})\nfor tu in active_tus:\n    print(f\"TU {tu.tu_id}: {tu.data.get('brief')}\")\n</code></pre>"},{"location":"api/state/#data-migration","title":"Data Migration","text":"<pre><code># Export from one project, import to another\nsource = WorkspaceManager(\"./project-a\")\ntarget = WorkspaceManager(\"./project-b\")\n\n# Copy all cold hooks\nhooks = source.list_cold_artifacts(\"hook_card\")\nfor hook in hooks:\n    target.save_cold_artifact(hook)\n\n# Copy project metadata\ninfo = source.get_project_info(\"cold\")\ninfo.name = \"Project B (Imported)\"\ntarget.save_project_info(info, target=\"cold\")\n</code></pre>"},{"location":"api/state/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use WorkspaceManager instead of directly using stores:    <pre><code># Good\nws = WorkspaceManager(\"./project\")\n\n# Avoid (unless you need low-level access)\nstore = SQLiteStore(\"./project.qfproj\")\n</code></pre></p> </li> <li> <p>Always use context managers to ensure resources are cleaned up:    <pre><code>with WorkspaceManager(\"./project\") as ws:\n    # Use workspace...\n</code></pre></p> </li> <li> <p>Work in hot, curate to cold:    <pre><code># Draft in hot\nws.save_hot_artifact(draft)\n\n# Review and iterate\n# ...\n\n# Promote when ready\nws.promote_to_cold(artifact_id)\n</code></pre></p> </li> <li> <p>Use batch operations for performance:    <pre><code># Good - single query\nartifacts = ws.cold_store.get_artifacts_by_ids(id_list)\n\n# Avoid - N queries\nartifacts = [ws.get_cold_artifact(id) for id in id_list]\n</code></pre></p> </li> <li> <p>Include metadata for filtering:    <pre><code>artifact.metadata = {\n    \"temperature\": \"hot\",\n    \"status\": \"draft\",\n    \"author\": \"Alice\",\n    \"created_by\": \"scene_smith\"\n}\n</code></pre></p> </li> <li> <p>Create snapshots at milestones:    <pre><code># After each chapter\nsnapshot = SnapshotInfo(\n    snapshot_id=f\"SNAP-{chapter}\",\n    tu_id=tu_id,\n    description=f\"Chapter {chapter} complete\"\n)\nws.save_snapshot(snapshot)\n</code></pre></p> </li> </ol>"},{"location":"api/state/#see-also","title":"See Also","text":"<ul> <li>Protocol API - Message passing with envelopes</li> <li>Export API - View generation and export</li> <li>Models API - Artifact types and schemas</li> </ul>"},{"location":"api/validation/","title":"Validation API Reference","text":"<p>The <code>questfoundry.validation</code> module provides quality assurance through quality bars and the Gatekeeper system. Quality bars are validation checks that content must pass before being promoted from hot workspace to cold storage.</p>"},{"location":"api/validation/#overview","title":"Overview","text":"<p>The validation module implements the 8 Quality Bars framework:</p> <ol> <li>Integrity - References resolve, no dead ends</li> <li>Reachability - Keystones and goals are reachable</li> <li>Style - Voice and register are consistent</li> <li>Gateways - Conditions are diegetic (in-world)</li> <li>Nonlinearity - Hubs and loops are meaningful</li> <li>Determinism - Assets are reproducible</li> <li>Presentation - No spoilers/internals on player surfaces</li> <li>Spoiler Hygiene - PN (Player Narrator) boundaries maintained</li> </ol>"},{"location":"api/validation/#quick-start","title":"Quick Start","text":"<pre><code>from questfoundry.validation import Gatekeeper\nfrom questfoundry.models import Artifact\n\n# Create artifacts to validate\nhooks = [\n    Artifact(\n        type=\"hook_card\",\n        data={\n            \"hook_id\": \"HOOK-001\",\n            \"title\": \"Dragon's Awakening\",\n            \"concept\": \"Ancient dragon stirs\"\n        }\n    ),\n    # ... more artifacts\n]\n\n# Run gatecheck\ngatekeeper = Gatekeeper()\nreport = gatekeeper.run_gatecheck(hooks)\n\n# Check results\nif report.passed:\n    print(\"\u2713 All quality bars passed - safe to promote to cold\")\nelse:\n    print(f\"\u2717 {len(report.blockers)} blockers found\")\n    for bar_name, issue in report.blockers:\n        print(f\"  [{bar_name}] {issue.message}\")\n\n# Generate artifact for audit trail\ngatecheck_artifact = report.to_artifact()\n</code></pre>"},{"location":"api/validation/#gatekeeper","title":"Gatekeeper","text":"<p>Main interface for running quality bar validation.</p>"},{"location":"api/validation/#constructor","title":"Constructor","text":"<pre><code>Gatekeeper(\n    bars: list[str] | None = None,\n    strict: bool = True\n)\n</code></pre> <p>Parameters: - <code>bars</code>: List of bar names to run (default: all 8 bars) - <code>strict</code>: If True, warnings also block merge (default: True)</p> <p>Available Bar Names: - <code>\"integrity\"</code> - Integrity Bar - <code>\"reachability\"</code> - Reachability Bar - <code>\"style\"</code> - Style Bar - <code>\"gateways\"</code> - Gateways Bar - <code>\"nonlinearity\"</code> - Nonlinearity Bar - <code>\"determinism\"</code> - Determinism Bar - <code>\"presentation\"</code> - Presentation Bar - <code>\"spoiler_hygiene\"</code> - Spoiler Hygiene Bar</p> <p>Example: <pre><code># Run all bars (default)\ngk = Gatekeeper()\n\n# Run specific bars only\ngk = Gatekeeper(bars=[\"integrity\", \"reachability\", \"style\"])\n\n# Allow warnings (non-strict mode)\ngk = Gatekeeper(strict=False)\n</code></pre></p>"},{"location":"api/validation/#methods","title":"Methods","text":""},{"location":"api/validation/#run_gatecheck","title":"<code>run_gatecheck()</code>","text":"<pre><code>def run_gatecheck(\n    artifacts: list[Artifact],\n    **metadata: Any\n) -&gt; GatecheckReport\n</code></pre> <p>Run full gatecheck on artifacts.</p> <p>Parameters: - <code>artifacts</code>: List of artifacts to validate - <code>**metadata</code>: Additional metadata to include in report (e.g., <code>tu_id</code>, <code>snapshot_id</code>)</p> <p>Returns: GatecheckReport with results from all bars</p> <p>Example: <pre><code>from datetime import datetime\n\nartifacts = [...]  # Your artifacts\n\nreport = gk.run_gatecheck(\n    artifacts,\n    tu_id=\"TU-2025-11-07-SR01\",\n    timestamp=datetime.now().isoformat(),\n    author=\"Alice\"\n)\n\nprint(f\"Passed: {report.passed}\")\nprint(f\"Merge Safe: {report.merge_safe}\")\nprint(f\"Blockers: {len(report.blockers)}\")\nprint(f\"Warnings: {len(report.warnings)}\")\n</code></pre></p>"},{"location":"api/validation/#gatecheckreport","title":"GatecheckReport","text":"<p>Complete gatecheck report with results from all quality bars.</p>"},{"location":"api/validation/#attributes","title":"Attributes","text":"<ul> <li><code>passed</code> (bool): Whether all bars passed (no blockers)</li> <li><code>merge_safe</code> (bool): Whether content can be merged to Cold</li> <li><code>bar_results</code> (dict[str, QualityBarResult]): Results from each quality bar</li> <li><code>summary</code> (str): Human-readable summary</li> <li><code>metadata</code> (dict[str, Any]): Additional context</li> </ul>"},{"location":"api/validation/#properties","title":"Properties","text":""},{"location":"api/validation/#all_issues","title":"<code>all_issues</code>","text":"<pre><code>@property\ndef all_issues() -&gt; list[tuple[str, QualityIssue]]\n</code></pre> <p>Get all issues across all bars.</p> <p>Returns: List of (bar_name, issue) tuples</p> <p>Example: <pre><code>for bar_name, issue in report.all_issues:\n    print(f\"[{bar_name}] {issue.severity}: {issue.message}\")\n</code></pre></p>"},{"location":"api/validation/#blockers","title":"<code>blockers</code>","text":"<pre><code>@property\ndef blockers() -&gt; list[tuple[str, QualityIssue]]\n</code></pre> <p>Get all blocker issues (must fix before merge).</p> <p>Returns: List of (bar_name, issue) tuples</p> <p>Example: <pre><code>if report.blockers:\n    print(\"Blockers that must be fixed:\")\n    for bar_name, issue in report.blockers:\n        print(f\"  [{bar_name}] {issue.message}\")\n        if issue.fix:\n            print(f\"    Fix: {issue.fix}\")\n</code></pre></p>"},{"location":"api/validation/#warnings","title":"<code>warnings</code>","text":"<pre><code>@property\ndef warnings() -&gt; list[tuple[str, QualityIssue]]\n</code></pre> <p>Get all warning issues (should review).</p> <p>Returns: List of (bar_name, issue) tuples</p> <p>Example: <pre><code>if report.warnings:\n    print(\"Warnings for review:\")\n    for bar_name, issue in report.warnings:\n        print(f\"  [{bar_name}] {issue.message}\")\n</code></pre></p>"},{"location":"api/validation/#methods_1","title":"Methods","text":""},{"location":"api/validation/#to_artifact","title":"<code>to_artifact()</code>","text":"<pre><code>def to_artifact() -&gt; Artifact\n</code></pre> <p>Convert report to gatecheck_report artifact for storage.</p> <p>Returns: Artifact of type \"gatecheck_report\"</p> <p>Example: <pre><code># Store gatecheck report in project\nreport_artifact = report.to_artifact()\nworkspace.save_hot_artifact(report_artifact)\n</code></pre></p>"},{"location":"api/validation/#quality-bar-types","title":"Quality Bar Types","text":"<p>All quality bars implement the <code>QualityBar</code> interface.</p>"},{"location":"api/validation/#qualitybar-abstract-base-class","title":"QualityBar (Abstract Base Class)","text":"<p>Base class for all quality bar validators.</p> <p>Abstract Properties: - <code>name</code> (str): Unique name of this quality bar - <code>description</code> (str): Short description of what this bar validates</p> <p>Abstract Method:</p>"},{"location":"api/validation/#validate","title":"<code>validate()</code>","text":"<pre><code>def validate(artifacts: list[Artifact]) -&gt; QualityBarResult\n</code></pre> <p>Validate artifacts against this quality bar.</p> <p>Parameters: - <code>artifacts</code>: List of artifacts to validate</p> <p>Returns: QualityBarResult with pass/fail and issues found</p>"},{"location":"api/validation/#available-quality-bars","title":"Available Quality Bars","text":""},{"location":"api/validation/#integritybar","title":"IntegrityBar","text":"<p>Validates that references resolve correctly and there are no dead ends.</p> <p>Checks: - All referenced artifact IDs exist - No dangling references - Cross-references are valid - Required fields are present</p> <p>Example: <pre><code>from questfoundry.validation import IntegrityBar\n\nbar = IntegrityBar()\nresult = bar.validate(artifacts)\n\nif not result.passed:\n    for issue in result.blockers:\n        print(f\"Integrity issue: {issue.message}\")\n</code></pre></p>"},{"location":"api/validation/#reachabilitybar","title":"ReachabilityBar","text":"<p>Validates that keystones and goals are reachable through the narrative.</p> <p>Checks: - All keystones can be reached - No unreachable content branches - Paths to goals exist - No orphaned scenes</p>"},{"location":"api/validation/#stylebar","title":"StyleBar","text":"<p>Validates voice and register consistency.</p> <p>Checks: - Consistent tone across content - Register (formal/informal) matches guidelines - Style guide adherence - Voice consistency</p>"},{"location":"api/validation/#gatewaysbar","title":"GatewaysBar","text":"<p>Validates that conditions and gates are diegetic (in-world).</p> <p>Checks: - Branching conditions make narrative sense - No metagaming requirements - Conditions are player-understandable - Gates feel natural</p>"},{"location":"api/validation/#nonlinearitybar","title":"NonlinearityBar","text":"<p>Validates that hubs and loops are meaningful.</p> <p>Checks: - Non-linear sections add value - Loops have purpose (not just filler) - Hubs provide meaningful choices - Paths converge sensibly</p>"},{"location":"api/validation/#determinismbar","title":"DeterminismBar","text":"<p>Validates that assets are reproducible.</p> <p>Checks: - Generation parameters are captured - Assets can be regenerated - Seeds/prompts are stored - Dependencies are documented</p>"},{"location":"api/validation/#presentationbar","title":"PresentationBar","text":"<p>Validates that no spoilers or internals leak to player surfaces.</p> <p>Checks: - No GM-only information visible - No internal IDs exposed - No development notes in output - Clean player-facing content</p>"},{"location":"api/validation/#spoilerhygienebar","title":"SpoilerHygieneBar","text":"<p>Validates PN (Player Narrator) boundaries are maintained.</p> <p>Checks: - Player-safe flag correctly set - Spoiler policy enforced - PN boundary not violated - Safe content properly marked</p>"},{"location":"api/validation/#qualitybarresult","title":"QualityBarResult","text":"<p>Result of a quality bar check.</p>"},{"location":"api/validation/#attributes_1","title":"Attributes","text":"<ul> <li><code>bar_name</code> (str): Name of the quality bar</li> <li><code>passed</code> (bool): Whether the bar passed (no blockers)</li> <li><code>issues</code> (list[QualityIssue]): List of issues found</li> <li><code>metadata</code> (dict[str, Any]): Additional context about the check</li> </ul>"},{"location":"api/validation/#properties_1","title":"Properties","text":""},{"location":"api/validation/#blockers_1","title":"<code>blockers</code>","text":"<pre><code>@property\ndef blockers() -&gt; list[QualityIssue]\n</code></pre> <p>Get only blocker issues.</p>"},{"location":"api/validation/#warnings_1","title":"<code>warnings</code>","text":"<pre><code>@property\ndef warnings() -&gt; list[QualityIssue]\n</code></pre> <p>Get only warning issues.</p>"},{"location":"api/validation/#info","title":"<code>info</code>","text":"<pre><code>@property\ndef info() -&gt; list[QualityIssue]\n</code></pre> <p>Get only info issues.</p> <p>Example: <pre><code>result = bar.validate(artifacts)\n\nprint(f\"Blockers: {len(result.blockers)}\")\nprint(f\"Warnings: {len(result.warnings)}\")\nprint(f\"Info: {len(result.info)}\")\n\nfor issue in result.blockers:\n    print(f\"BLOCKER: {issue.message} at {issue.location}\")\n</code></pre></p>"},{"location":"api/validation/#qualityissue","title":"QualityIssue","text":"<p>An issue found during quality bar validation.</p>"},{"location":"api/validation/#attributes_2","title":"Attributes","text":"<ul> <li><code>severity</code> (str): \"blocker\", \"warning\", or \"info\"</li> <li><code>message</code> (str): Human-readable description</li> <li><code>location</code> (str): Where the issue was found (artifact_id, field, section, etc.)</li> <li><code>fix</code> (str): Suggested remediation (optional)</li> </ul> <p>Example: <pre><code>issue = QualityIssue(\n    severity=\"blocker\",\n    message=\"Referenced artifact HOOK-002 not found\",\n    location=\"SCENE-001.prerequisites\",\n    fix=\"Add HOOK-002 or remove reference\"\n)\n</code></pre></p>"},{"location":"api/validation/#utility-functions","title":"Utility Functions","text":""},{"location":"api/validation/#get_quality_bar","title":"<code>get_quality_bar()</code>","text":"<pre><code>def get_quality_bar(name: str) -&gt; type[QualityBar]\n</code></pre> <p>Get a quality bar class by name.</p> <p>Parameters: - <code>name</code>: Quality bar name (e.g., \"integrity\", \"reachability\")</p> <p>Returns: Quality bar class</p> <p>Raises: - <code>ValueError</code>: If bar name is unknown</p> <p>Example: <pre><code>from questfoundry.validation import get_quality_bar\n\nIntegrityBarClass = get_quality_bar(\"integrity\")\nbar = IntegrityBarClass()\nresult = bar.validate(artifacts)\n</code></pre></p>"},{"location":"api/validation/#quality_bars","title":"<code>QUALITY_BARS</code>","text":"<p>Dictionary mapping bar names to bar classes.</p> <pre><code>QUALITY_BARS = {\n    \"integrity\": IntegrityBar,\n    \"reachability\": ReachabilityBar,\n    \"style\": StyleBar,\n    \"gateways\": GatewaysBar,\n    \"nonlinearity\": NonlinearityBar,\n    \"determinism\": DeterminismBar,\n    \"presentation\": PresentationBar,\n    \"spoiler_hygiene\": SpoilerHygieneBar,\n}\n</code></pre> <p>Example: <pre><code>from questfoundry.validation import QUALITY_BARS\n\n# List all available bars\nfor bar_name, bar_class in QUALITY_BARS.items():\n    bar = bar_class()\n    print(f\"{bar_name}: {bar.description}\")\n</code></pre></p>"},{"location":"api/validation/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/validation/#basic-gatecheck-workflow","title":"Basic Gatecheck Workflow","text":"<pre><code>from questfoundry.validation import Gatekeeper\nfrom questfoundry.state import WorkspaceManager\n\n# Initialize\nws = WorkspaceManager(\"./project\")\ngk = Gatekeeper()\n\n# Get artifacts from hot workspace\nartifacts = ws.list_hot_artifacts()\n\n# Run gatecheck\nreport = gk.run_gatecheck(\n    artifacts,\n    tu_id=\"TU-2025-11-07-SR01\"\n)\n\n# Process results\nif report.merge_safe:\n    print(\"\u2713 Safe to promote to cold\")\n    # Promote artifacts\n    for artifact in artifacts:\n        artifact_id = artifact.metadata.get(\"id\")\n        if artifact_id:\n            ws.promote_to_cold(artifact_id)\nelse:\n    print(f\"\u2717 Cannot merge - {len(report.blockers)} blockers\")\n    # Store report for review\n    ws.save_hot_artifact(report.to_artifact())\n</code></pre>"},{"location":"api/validation/#selective-bar-validation","title":"Selective Bar Validation","text":"<pre><code># Only run critical bars\ngk = Gatekeeper(bars=[\"integrity\", \"reachability\", \"spoiler_hygiene\"])\nreport = gk.run_gatecheck(artifacts)\n\n# Check specific bar results\nintegrity_result = report.bar_results.get(\"integrity\")\nif integrity_result and not integrity_result.passed:\n    print(\"Integrity check failed:\")\n    for issue in integrity_result.blockers:\n        print(f\"  {issue.message}\")\n</code></pre>"},{"location":"api/validation/#detailed-issue-reporting","title":"Detailed Issue Reporting","text":"<pre><code>report = gk.run_gatecheck(artifacts)\n\n# Group issues by severity\nprint(\"\\n=== BLOCKERS ===\")\nfor bar_name, issue in report.blockers:\n    print(f\"[{bar_name}] {issue.location}\")\n    print(f\"  Problem: {issue.message}\")\n    if issue.fix:\n        print(f\"  Fix: {issue.fix}\")\n\nprint(\"\\n=== WARNINGS ===\")\nfor bar_name, issue in report.warnings:\n    print(f\"[{bar_name}] {issue.message}\")\n\nprint(\"\\n=== SUMMARY ===\")\nprint(f\"Total issues: {len(report.all_issues)}\")\nprint(f\"Blockers: {len(report.blockers)}\")\nprint(f\"Warnings: {len(report.warnings)}\")\n</code></pre>"},{"location":"api/validation/#custom-validation-pipeline","title":"Custom Validation Pipeline","text":"<pre><code>from questfoundry.validation import get_quality_bar\n\n# Create custom validation pipeline\npipeline = [\n    (\"Pre-merge\", [\"integrity\", \"reachability\"]),\n    (\"Content Quality\", [\"style\", \"gateways\", \"nonlinearity\"]),\n    (\"Player Safety\", [\"presentation\", \"spoiler_hygiene\"]),\n]\n\nall_passed = True\nfor stage_name, bar_names in pipeline:\n    print(f\"\\n{stage_name}:\")\n    stage_passed = True\n\n    for bar_name in bar_names:\n        bar_class = get_quality_bar(bar_name)\n        bar = bar_class()\n        result = bar.validate(artifacts)\n\n        if result.passed:\n            print(f\"  \u2713 {bar_name}\")\n        else:\n            print(f\"  \u2717 {bar_name} - {len(result.blockers)} blockers\")\n            stage_passed = False\n\n    if not stage_passed:\n        all_passed = False\n        print(f\"  Stage failed - fix issues before continuing\")\n        break\n\nif all_passed:\n    print(\"\\n\u2713 All validation stages passed!\")\n</code></pre>"},{"location":"api/validation/#integration-with-roles","title":"Integration with Roles","text":"<pre><code>from questfoundry.validation import Gatekeeper\n\nclass GatekeeperRole:\n    \"\"\"Gatekeeper role that validates content.\"\"\"\n\n    def __init__(self):\n        self.gatekeeper = Gatekeeper()\n\n    def validate_content(self, artifacts):\n        \"\"\"Run gatecheck and return report.\"\"\"\n        report = self.gatekeeper.run_gatecheck(artifacts)\n\n        if not report.passed:\n            # Generate feedback for other roles\n            feedback = self._generate_feedback(report)\n            return {\"approved\": False, \"feedback\": feedback}\n        else:\n            return {\"approved\": True, \"report_id\": \"...\"}\n\n    def _generate_feedback(self, report):\n        \"\"\"Convert issues to actionable feedback.\"\"\"\n        feedback = []\n        for bar_name, issue in report.blockers:\n            feedback.append({\n                \"bar\": bar_name,\n                \"severity\": issue.severity,\n                \"message\": issue.message,\n                \"location\": issue.location,\n                \"fix\": issue.fix\n            })\n        return feedback\n</code></pre>"},{"location":"api/validation/#validation-reporting","title":"Validation Reporting","text":"<pre><code># Generate detailed report\nreport = gk.run_gatecheck(artifacts, author=\"Alice\")\n\n# Convert to artifact for storage\nreport_artifact = report.to_artifact()\n\n# Save to workspace\nws.save_hot_artifact(report_artifact)\n\n# Also save as markdown\ndef report_to_markdown(report):\n    lines = [\n        f\"# Gatecheck Report\",\n        f\"\",\n        f\"**Status:** {'\u2713 PASSED' if report.passed else '\u2717 FAILED'}\",\n        f\"**Merge Safe:** {'Yes' if report.merge_safe else 'No'}\",\n        f\"**Blockers:** {len(report.blockers)}\",\n        f\"**Warnings:** {len(report.warnings)}\",\n        f\"\",\n    ]\n\n    if report.blockers:\n        lines.append(\"## Blockers\")\n        lines.append(\"\")\n        for bar_name, issue in report.blockers:\n            lines.append(f\"### [{bar_name}] {issue.location}\")\n            lines.append(f\"- **Problem:** {issue.message}\")\n            if issue.fix:\n                lines.append(f\"- **Fix:** {issue.fix}\")\n            lines.append(\"\")\n\n    if report.warnings:\n        lines.append(\"## Warnings\")\n        lines.append(\"\")\n        for bar_name, issue in report.warnings:\n            lines.append(f\"- **[{bar_name}]** {issue.message}\")\n\n    return \"\\n\".join(lines)\n\nmarkdown = report_to_markdown(report)\nPath(\"gatecheck_report.md\").write_text(markdown)\n</code></pre>"},{"location":"api/validation/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Run gatechecks before promotion:    <pre><code># Always validate before promoting to cold\nreport = gk.run_gatecheck(hot_artifacts)\nif report.merge_safe:\n    promote_to_cold(hot_artifacts)\n</code></pre></p> </li> <li> <p>Store gatecheck reports:    <pre><code># Keep audit trail of all gatechecks\nreport_artifact = report.to_artifact()\nws.save_hot_artifact(report_artifact)\n</code></pre></p> </li> <li> <p>Use strict mode for production:    <pre><code># Strict mode treats warnings as blockers\ngk = Gatekeeper(strict=True)\n</code></pre></p> </li> <li> <p>Run incrementally:    <pre><code># Run critical bars first, then full check\ncritical = Gatekeeper(bars=[\"integrity\", \"spoiler_hygiene\"])\nif not critical.run_gatecheck(artifacts).passed:\n    return  # Fix critical issues first\n\nfull = Gatekeeper()\nreport = full.run_gatecheck(artifacts)\n</code></pre></p> </li> <li> <p>Provide actionable feedback:    <pre><code># Always include location and fix suggestions\nfor bar_name, issue in report.blockers:\n    print(f\"Location: {issue.location}\")\n    print(f\"Problem: {issue.message}\")\n    if issue.fix:\n        print(f\"How to fix: {issue.fix}\")\n</code></pre></p> </li> </ol>"},{"location":"api/validation/#see-also","title":"See Also","text":"<ul> <li>State Management API - Hot/cold promotion</li> <li>Export API - View generation with safety checks</li> <li>Models API - Artifact types</li> </ul>"},{"location":"examples/code-examples/","title":"Code Examples","text":"<p>Practical code examples for common QuestFoundry-Py tasks.</p>"},{"location":"examples/code-examples/#creating-a-workspace","title":"Creating a Workspace","text":"<pre><code>from questfoundry.state.workspace import WorkspaceManager\n\n# Create workspace\nworkspace = WorkspaceManager(\"./my_project\")\n\n# Initialize with project info\nworkspace.init_workspace(\n    name=\"My Story Project\",\n    description=\"An interactive fantasy adventure\"\n)\n\nprint(\"Workspace initialized!\")\n</code></pre>"},{"location":"examples/code-examples/#configuring-providers","title":"Configuring Providers","text":""},{"location":"examples/code-examples/#using-openai","title":"Using OpenAI","text":"<pre><code># .questfoundry/config.yml\nproviders:\n  text:\n    default: openai\n    openai:\n      api_key: ${OPENAI_API_KEY}\n      model: gpt-4o\n      temperature: 0.7\n      cache:\n        enabled: true\n</code></pre>"},{"location":"examples/code-examples/#per-role-configuration","title":"Per-Role Configuration","text":"<pre><code>providers:\n  text:\n    openai:\n      model: gpt-4o\n\nroles:\n  gatekeeper:\n    provider: openai\n    model: gpt-4o  # Premium model for quality\n  plotwright:\n    provider: openai\n    model: gpt-3.5-turbo  # Cheaper for planning\n</code></pre>"},{"location":"examples/code-examples/#running-a-simple-loop","title":"Running a Simple Loop","text":"<pre><code>from questfoundry.orchestrator import Orchestrator\nfrom questfoundry.state.workspace import WorkspaceManager\n\nworkspace = WorkspaceManager(\"./my_project\")\norchestrator = Orchestrator(workspace)\n\n# Execute story spark loop\nresult = orchestrator.execute_loop(\n    loop_id=\"story_spark\",\n    project_id=\"my_project\",\n    config={\n        \"prompt\": \"A hidden library in the mountains\",\n        \"style\": \"fantasy adventure\"\n    }\n)\n\nif result.success:\n    print(f\"\u2705 Loop completed!\")\n    print(f\"Artifacts created: {len(result.artifacts_created)}\")\n    for artifact in result.artifacts_created:\n        print(f\"  - {artifact.type}: {artifact.artifact_id}\")\nelse:\n    print(f\"\u274c Failed: {result.error}\")\n</code></pre>"},{"location":"examples/code-examples/#accessing-artifacts","title":"Accessing Artifacts","text":"<pre><code>from questfoundry.state.workspace import WorkspaceManager\n\nworkspace = WorkspaceManager(\"./my_project\")\n\n# Get specific artifact\nartifact = workspace.get_artifact(\"ARTIFACT-123\")\nprint(f\"Artifact type: {artifact.type}\")\nprint(f\"Artifact data: {artifact.data}\")\n\n# List artifacts by type\nhooks = workspace.list_artifacts(artifact_type=\"hook_card\")\nprint(f\"Found {len(hooks)} hooks\")\n\n# List artifacts in a snapshot\nsnapshot_artifacts = workspace.list_artifacts(snapshot_id=\"SNAP-456\")\nprint(f\"Snapshot contains {len(snapshot_artifacts)} artifacts\")\n</code></pre>"},{"location":"examples/code-examples/#managing-state","title":"Managing State","text":""},{"location":"examples/code-examples/#saving-thematic-units","title":"Saving Thematic Units","text":"<pre><code>from questfoundry.state.workspace import WorkspaceManager\nfrom questfoundry.state.types import TUState\n\nworkspace = WorkspaceManager(\"./my_project\")\n\n# Create a TU\ntu = TUState(\n    tu_id=\"TU-2024-01-15-INTRO\",\n    status=\"in_progress\",\n    data={\n        \"title\": \"Introduction\",\n        \"description\": \"The story begins...\",\n    }\n)\n\n# Save to hot storage (active/working)\nworkspace.save_tu(tu, target=\"hot\")\n\n# Later, promote to cold storage (archived)\nworkspace.promote_to_cold(tu.tu_id)\n</code></pre>"},{"location":"examples/code-examples/#creating-snapshots","title":"Creating Snapshots","text":"<pre><code>from questfoundry.state.types import SnapshotInfo\nfrom datetime import datetime\n\nworkspace = WorkspaceManager(\"./my_project\")\n\n# Create snapshot\nsnapshot = SnapshotInfo(\n    snapshot_id=\"SNAP-001\",\n    tu_id=\"TU-2024-01-15-INTRO\",\n    description=\"After first draft completion\"\n)\n\nworkspace.save_snapshot(snapshot)\n\n# Save artifacts to snapshot\nartifact = workspace.get_artifact(\"ARTIFACT-123\")\nworkspace.save_artifact(artifact, snapshot_id=\"SNAP-001\")\n</code></pre>"},{"location":"examples/code-examples/#exporting-state","title":"Exporting State","text":"<pre><code>workspace = WorkspaceManager(\"./my_project\")\n\n# Export to file\nworkspace.export_state(\n    \"export.yaml\",\n    include=[\"artifacts\", \"tus\", \"snapshots\"]\n)\n\n# Import from file\nworkspace.import_state(\"export.yaml\", merge=True)\n</code></pre>"},{"location":"examples/code-examples/#error-handling","title":"Error Handling","text":"<pre><code>from questfoundry.orchestrator import Orchestrator\nfrom questfoundry.state.workspace import WorkspaceManager\n\nworkspace = WorkspaceManager(\"./my_project\")\norchestrator = Orchestrator(workspace)\n\ntry:\n    result = orchestrator.execute_loop(\n        loop_id=\"story_spark\",\n        project_id=\"my_project\",\n        config={\"prompt\": \"A story concept\"}\n    )\n\n    if not result.success:\n        print(f\"Loop failed: {result.error}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n    # Handle unexpected errors\n</code></pre>"},{"location":"examples/code-examples/#custom-provider","title":"Custom Provider","text":"<pre><code>from questfoundry.providers.base import TextProvider\n\nclass CustomProvider(TextProvider):\n    \"\"\"Custom text provider.\"\"\"\n\n    def validate_config(self) -&gt; None:\n        \"\"\"Validate configuration.\"\"\"\n        if \"api_key\" not in self.config:\n            raise ValueError(\"api_key required\")\n\n    def generate_text(\n        self,\n        prompt: str,\n        model: str | None = None,\n        **kwargs\n    ) -&gt; str:\n        \"\"\"Generate text using custom API.\"\"\"\n        # Your implementation here\n        return \"Generated text\"\n\n    def generate_text_streaming(\n        self,\n        prompt: str,\n        model: str | None = None,\n        **kwargs\n    ):\n        \"\"\"Generate text streaming.\"\"\"\n        yield \"chunk1\"\n        yield \"chunk2\"\n\n# Use custom provider directly\nprovider = CustomProvider({\"api_key\": \"your-api-key\"})\ntext = provider.generate_text(\"Hello, world!\")\nprint(f\"Generated: {text}\")\n</code></pre>"},{"location":"examples/code-examples/#full-example-mini-project","title":"Full Example: Mini Project","text":"<pre><code>from questfoundry.orchestrator import Orchestrator\nfrom questfoundry.state.workspace import WorkspaceManager\n\ndef main():\n    # Setup\n    workspace = WorkspaceManager(\"./story_project\")\n    workspace.init_workspace(name=\"Short Story\")\n    orchestrator = Orchestrator(workspace)\n\n    # Generate story concept\n    result = orchestrator.execute_loop(\n        loop_id=\"story_spark\",\n        project_id=\"time_travel_story\",\n        config={\"prompt\": \"A time traveler arrives in ancient Rome\"}\n    )\n\n    if not result.success:\n        print(f\"Failed: {result.error}\")\n        return\n\n    print(f\"\u2705 Story created with {len(result.artifacts_created)} artifacts\")\n\n    # List what was created\n    artifacts = workspace.list_artifacts()\n    for artifact in artifacts:\n        print(f\"  - {artifact.type}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/code-examples/#more-resources","title":"More Resources","text":"<ul> <li>Configuration Guide - All configuration options</li> <li>API Reference - Complete API docs</li> <li>Guides - How-to guides</li> </ul>"},{"location":"guides/getting-started/","title":"Getting Started with QuestFoundry","text":"<p>This guide will help you get started with QuestFoundry, from installation to creating your first interactive narrative project.</p>"},{"location":"guides/getting-started/#installation","title":"Installation","text":""},{"location":"guides/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or later</li> <li>pip or uv package manager</li> <li>(Optional) Git for version control</li> </ul>"},{"location":"guides/getting-started/#install-questfoundry","title":"Install QuestFoundry","text":"<pre><code># Install with pip\npip install questfoundry-py\n\n# Or with uv (recommended)\nuv pip install questfoundry-py\n\n# Install with provider support\npip install questfoundry-py[openai]  # For OpenAI integration\npip install questfoundry-py[all]     # All optional dependencies\n</code></pre>"},{"location":"guides/getting-started/#verify-installation","title":"Verify Installation","text":"<pre><code>import questfoundry\nprint(questfoundry.__version__)\n</code></pre>"},{"location":"guides/getting-started/#initial-setup","title":"Initial Setup","text":""},{"location":"guides/getting-started/#1-set-up-environment-variables","title":"1. Set Up Environment Variables","text":"<p>Create a <code>.env</code> file in your project directory:</p> <pre><code># OpenAI (if using)\nOPENAI_API_KEY=sk-your-api-key-here\n\n# Or Ollama (if using local models)\nOLLAMA_BASE_URL=http://localhost:11434\n</code></pre>"},{"location":"guides/getting-started/#2-initialize-a-project","title":"2. Initialize a Project","text":"<pre><code>from questfoundry.state import WorkspaceManager\n\n# Create and initialize workspace\nws = WorkspaceManager(\"./my-adventure\")\nws.init_workspace(\n    name=\"My First Adventure\",\n    description=\"An epic fantasy quest\",\n    author=\"Your Name\"\n)\n\nprint(\"Project initialized!\")\n</code></pre> <p>This creates: <pre><code>my-adventure/\n  .questfoundry/\n    hot/              # Work-in-progress files\n    metadata.json     # Project configuration\n  project.qfproj      # SQLite database\n</code></pre></p>"},{"location":"guides/getting-started/#3-configure-providers","title":"3. Configure Providers","text":"<p>Create <code>.questfoundry/config.yml</code>:</p> <pre><code>providers:\n  text:\n    default: openai\n    openai:\n      api_key: ${OPENAI_API_KEY}\n      model: gpt-4o\n\n  image:\n    default: dalle\n    dalle:\n      api_key: ${OPENAI_API_KEY}\n      model: dall-e-3\n</code></pre>"},{"location":"guides/getting-started/#your-first-workflow","title":"Your First Workflow","text":""},{"location":"guides/getting-started/#step-1-create-artifacts","title":"Step 1: Create Artifacts","text":"<pre><code>from questfoundry.models import Artifact\n\n# Create a hook (story concept)\nhook = Artifact(\n    type=\"hook_card\",\n    data={\n        \"hook_id\": \"HOOK-001\",\n        \"title\": \"The Dragon's Awakening\",\n        \"concept\": \"An ancient dragon stirs after a thousand years of slumber\",\n        \"stakes\": \"The kingdom faces destruction unless heroes intervene\",\n        \"twist\": \"The dragon was protecting the kingdom, not threatening it\"\n    },\n    metadata={\"temperature\": \"hot\", \"status\": \"draft\"}\n)\n\n# Save to workspace\nws.save_hot_artifact(hook)\nprint(f\"Created hook: {hook.data['hook_id']}\")\n</code></pre>"},{"location":"guides/getting-started/#step-2-validate-content","title":"Step 2: Validate Content","text":"<pre><code>from questfoundry.validation import Gatekeeper\n\n# Get all hot artifacts\nartifacts = ws.list_hot_artifacts()\n\n# Run quality check\ngatekeeper = Gatekeeper()\nreport = gatekeeper.run_gatecheck(artifacts)\n\nif report.passed:\n    print(\"\u2713 All quality checks passed\")\nelse:\n    print(f\"\u2717 Found {len(report.blockers)} issues:\")\n    for bar_name, issue in report.blockers:\n        print(f\"  [{bar_name}] {issue.message}\")\n</code></pre>"},{"location":"guides/getting-started/#step-3-promote-to-cold-storage","title":"Step 3: Promote to Cold Storage","text":"<pre><code>if report.passed:\n    # Promote approved content\n    ws.promote_to_cold(\"HOOK-001\")\n    print(\"Hook promoted to cold storage\")\n</code></pre>"},{"location":"guides/getting-started/#step-4-create-a-snapshot","title":"Step 4: Create a Snapshot","text":"<pre><code>from questfoundry.state import SnapshotInfo, TUState\nfrom datetime import datetime\n\n# Create TU (Thematic Unit)\ntu = TUState(\n    tu_id=\"TU-2025-11-07-SR01\",\n    status=\"completed\",\n    data={\"brief\": \"Initial hook development\"}\n)\nws.save_tu(tu)\n\n# Create snapshot\nsnapshot_id = \"SNAP-2025-11-07-001\"\nsnapshot = SnapshotInfo(\n    snapshot_id=snapshot_id,\n    tu_id=tu.tu_id,\n    description=\"First hook complete\"\n)\nws.save_snapshot(snapshot)\nprint(f\"Created snapshot: {snapshot_id}\")\n</code></pre>"},{"location":"guides/getting-started/#step-5-generate-a-view-and-export","title":"Step 5: Generate a View and Export","text":"<pre><code>from questfoundry.export import ViewGenerator, BookBinder\n\n# Generate player-safe view (using snapshot_id from previous step)\nsnapshot_id = \"SNAP-2025-11-07-001\"\nview_gen = ViewGenerator(ws.cold_store)\nview = view_gen.generate_view(snapshot_id)\nprint(f\"View contains {len(view.artifacts)} player-safe artifacts\")\n\n# Render to HTML\nbinder = BookBinder()\nhtml = binder.render_html(view, title=\"Chapter 1\")\nbinder.save_html(html, \"./output/chapter1.html\")\nprint(\"Rendered to HTML!\")\n</code></pre>"},{"location":"guides/getting-started/#working-with-providers","title":"Working with Providers","text":""},{"location":"guides/getting-started/#using-openai","title":"Using OpenAI","text":"<pre><code>from questfoundry.providers import ProviderRegistry, ProviderConfig\n\n# Setup\nconfig = ProviderConfig()\nregistry = ProviderRegistry(config)\n\n# Get provider\nprovider = registry.get_text_provider(\"openai\")\n\n# Generate text\nresponse = provider.generate_text(\n    prompt=\"Write a fantasy hook about a dragon\",\n    max_tokens=200,\n    temperature=0.8\n)\nprint(response)\n</code></pre>"},{"location":"guides/getting-started/#using-local-models-ollama","title":"Using Local Models (Ollama)","text":"<pre><code># Use Ollama for local generation\nollama = registry.get_text_provider(\"ollama\")\n\nresponse = ollama.generate_text(\n    prompt=\"Describe a mystical forest\",\n    max_tokens=150\n)\nprint(response)\n</code></pre>"},{"location":"guides/getting-started/#next-steps","title":"Next Steps","text":""},{"location":"guides/getting-started/#learn-more","title":"Learn More","text":"<ul> <li>API Reference - Detailed API documentation</li> <li>State Management API - Working with hot/cold storage</li> <li>Provider API - Configuring LLM providers</li> <li>Export API - Generating player-facing content</li> </ul>"},{"location":"guides/getting-started/#explore-advanced-features","title":"Explore Advanced Features","text":"<ol> <li>Role-Based Workflows: Use specialized roles for different tasks</li> <li>Loop Orchestration: Run multi-step workflows</li> <li>Quality Gates: Enforce quality standards</li> <li>Git Export: Version control your content</li> </ol>"},{"location":"guides/getting-started/#example-projects","title":"Example Projects","text":"<p>See the <code>examples/</code> directory for complete project templates: - <code>examples/fantasy-quest/</code> - Complete fantasy adventure - <code>examples/sci-fi-mystery/</code> - Science fiction mystery - <code>examples/minimal/</code> - Minimal starter project</p>"},{"location":"guides/getting-started/#common-tasks","title":"Common Tasks","text":""},{"location":"guides/getting-started/#list-all-artifacts","title":"List All Artifacts","text":"<pre><code># List hot artifacts\nhot_artifacts = ws.list_hot_artifacts()\nfor artifact in hot_artifacts:\n    print(f\"{artifact.type}: {artifact.artifact_id}\")\n\n# List cold artifacts\ncold_artifacts = ws.list_cold_artifacts(\"hook_card\")\nprint(f\"Found {len(cold_artifacts)} hooks in cold storage\")\n</code></pre>"},{"location":"guides/getting-started/#query-by-type-and-filters","title":"Query by Type and Filters","text":"<pre><code># Get draft hooks\ndrafts = ws.list_hot_artifacts(\n    \"hook_card\",\n    {\"status\": \"draft\"}\n)\n\n# Get approved canon\ncanon = ws.list_cold_artifacts(\n    \"canon_pack\",\n    {\"status\": \"approved\"}\n)\n</code></pre>"},{"location":"guides/getting-started/#update-an-artifact","title":"Update an Artifact","text":"<pre><code># Get artifact\nartifact = ws.get_hot_artifact(\"HOOK-001\")\n\n# Modify\nartifact.data[\"concept\"] += \" - Now with more dragons!\"\nartifact.data[\"status\"] = \"revised\"\n\n# Save changes\nws.save_hot_artifact(artifact)\n</code></pre>"},{"location":"guides/getting-started/#delete-an-artifact","title":"Delete an Artifact","text":"<pre><code># Delete from hot\nws.delete_hot_artifact(\"HOOK-001\")\n\n# Delete from cold\nws.delete_cold_artifact(\"HOOK-001\")\n</code></pre>"},{"location":"guides/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/getting-started/#provider-configuration-issues","title":"Provider Configuration Issues","text":"<p>If you see <code>ValueError: Environment variable 'OPENAI_API_KEY' is not set</code>:</p> <ol> <li>Create a <code>.env</code> file with your API key</li> <li>Or set environment variable: <code>export OPENAI_API_KEY=sk-...</code></li> <li>Verify config.yml uses <code>${OPENAI_API_KEY}</code> syntax</li> </ol>"},{"location":"guides/getting-started/#import-errors","title":"Import Errors","text":"<p>If you see <code>ModuleNotFoundError</code>:</p> <pre><code># Install with provider support\npip install questfoundry-py[openai]\n\n# Or install all dependencies\npip install questfoundry-py[all]\n</code></pre>"},{"location":"guides/getting-started/#database-locked","title":"Database Locked","text":"<p>If you see <code>database is locked</code>:</p> <pre><code># Always close connections\nwith WorkspaceManager(\"./project\") as ws:\n    # Use workspace\n    pass\n# Automatically closed\n\n# Or manually\nws.close()\n</code></pre>"},{"location":"guides/getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation - Complete API reference</li> <li>GitHub Issues - Report bugs</li> <li>Discussions - Ask questions</li> <li>Specification - System design</li> </ul>"},{"location":"guides/getting-started/#whats-next","title":"What's Next?","text":"<p>Now that you've completed the getting started guide, explore:</p> <ol> <li>State Management - Master hot/cold workflow</li> <li>Providers - Configure LLM and image providers</li> <li>Validation - Quality gates and gatekeeping</li> <li>Export - Generate player-facing content</li> <li>Architecture - Understand the system design</li> </ol> <p>Happy quest building! \ud83c\udfae\u2728</p>"}]}